# sample.docx

This is a binary file of the type: Word Document

# config.ru

```ru
# This file is used by Rack-based servers to start the application.

require_relative "config/environment"

run Rails.application
Rails.application.load_server

```

# Rakefile

```
# Add your own tasks in files placed in lib/tasks ending in .rake,
# for example lib/tasks/capistrano.rake, and they will automatically be available to Rake.

require_relative "config/application"

Rails.application.load_tasks

```

# README.md

```md
# Interview

This repo is the boilerplate we ask candidates to check out as part of the interview process. This is a Rails project running Rails 7 and Ruby 3.2. 

Before your interview starts, we recommend forking this repo and making sure that the following commands work:

\`\`\`
bundle install
bin/rails s
\`\`\`

Interested in a role at Scholarly? Email <a href="mailto:careers@scholarlysoftware.com">careers@scholarlysoftware.com</a>

```

# Gemfile

```
source "https://rubygems.org"
git_source(:github) { |repo| "https://github.com/#{repo}.git" }

ruby "3.3.3"

# Bundle edge Rails instead: gem "rails", github: "rails/rails", branch: "main"
gem "rails", "~> 7.1"

# The original asset pipeline for Rails [https://github.com/rails/sprockets-rails]
gem "sprockets-rails"

# Use sqlite3 as the database for Active Record
gem "sqlite3", "~> 1.4"

# Use the Puma web server [https://github.com/puma/puma]
gem "puma", "~> 6"

# Use JavaScript with ESM import maps [https://github.com/rails/importmap-rails]
gem "importmap-rails"

# Hotwire's SPA-like page accelerator [https://turbo.hotwired.dev]
gem "turbo-rails"

# Hotwire's modest JavaScript framework [https://stimulus.hotwired.dev]
gem "stimulus-rails"

# Build JSON APIs with ease [https://github.com/rails/jbuilder]
gem "jbuilder"

# Use Redis adapter to run Action Cable in production
gem "redis", "~> 4.0"

# Use Kredis to get higher-level data types in Redis [https://github.com/rails/kredis]
# gem "kredis"

# Use Active Model has_secure_password [https://guides.rubyonrails.org/active_model_basics.html#securepassword]
# gem "bcrypt", "~> 3.1.7"

# Windows does not include zoneinfo files, so bundle the tzinfo-data gem
gem "tzinfo-data", platforms: %i[ mingw mswin x64_mingw jruby ]

# Reduces boot times through caching; required in config/boot.rb
gem "bootsnap", require: false

# Use Sass to process CSS
# gem "sassc-rails"

# Use Active Storage variants [https://guides.rubyonrails.org/active_storage_overview.html#transforming-images]
# gem "image_processing", "~> 1.2"

group :development, :test do
  # See https://guides.rubyonrails.org/debugging_rails_applications.html#debugging-with-the-debug-gem
  gem "debug", platforms: %i[ mri mingw x64_mingw ]
end

group :development do
  # Use console on exceptions pages [https://github.com/rails/web-console]
  gem "web-console"

  # Add speed badges [https://github.com/MiniProfiler/rack-mini-profiler]
  # gem "rack-mini-profiler"

  # Speed up commands on slow machines / big apps [https://github.com/rails/spring]
  # gem "spring"
end

group :test do
  # Use system testing [https://guides.rubyonrails.org/testing.html#system-testing]
  gem "capybara"
  gem "selenium-webdriver"
  gem "webdrivers"
end

```

# .ruby-version

```
ruby-3.3.3

```

# .gitignore

```
# See https://help.github.com/articles/ignoring-files for more about ignoring files.
#
# If you find yourself ignoring temporary files generated by your text editor
# or operating system, you probably want to add a global ignore instead:
#   git config --global core.excludesfile '~/.gitignore_global'

# Ignore bundler config.
/.bundle

# Ignore the default SQLite database.
/db/*.sqlite3
/db/*.sqlite3-*

# Ignore all logfiles and tempfiles.
/log/*
/tmp/*
!/log/.keep
!/tmp/.keep

# Ignore pidfiles, but keep the directory.
/tmp/pids/*
!/tmp/pids/
!/tmp/pids/.keep

# Ignore uploaded files in development.
/storage/*
!/storage/.keep
/tmp/storage/*
!/tmp/storage/
!/tmp/storage/.keep

/public/assets

# Ignore master key for decrypting credentials and more.
/config/master.key

```

# .gitattributes

```
# See https://git-scm.com/docs/gitattributes for more about git attribute files.

# Mark the database schema as having been generated.
db/schema.rb linguist-generated

# Mark any vendored files as having been vendored.
vendor/* linguist-vendored

```

# .aidigestignore

```
log
storage
tmp
vendor
```

# test/test_helper.rb

```rb
ENV["RAILS_ENV"] ||= "test"
require_relative "../config/environment"
require "rails/test_help"

class ActiveSupport::TestCase
  # Run tests in parallel with specified workers
  parallelize(workers: :number_of_processors)

  # Setup all fixtures in test/fixtures/*.yml for all tests in alphabetical order.
  fixtures :all

  # Add more helper methods to be used by all tests here...
end

```

# test/application_system_test_case.rb

```rb
require "test_helper"

class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
  driven_by :selenium, using: :chrome, screen_size: [1400, 1400]
end

```

# public/robots.txt

```txt
# See https://www.robotstxt.org/robotstxt.html for documentation on how to use the robots.txt file

```

# public/favicon.ico

```ico

```

# public/apple-touch-icon.png

This is a binary file of the type: Image

# public/apple-touch-icon-precomposed.png

This is a binary file of the type: Image

# public/500.html

```html
<!DOCTYPE html>
<html>
<head>
  <title>We're sorry, but something went wrong (500)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
  .rails-default-error-page {
    background-color: #EFEFEF;
    color: #2E2F30;
    text-align: center;
    font-family: arial, sans-serif;
    margin: 0;
  }

  .rails-default-error-page div.dialog {
    width: 95%;
    max-width: 33em;
    margin: 4em auto 0;
  }

  .rails-default-error-page div.dialog > div {
    border: 1px solid #CCC;
    border-right-color: #999;
    border-left-color: #999;
    border-bottom-color: #BBB;
    border-top: #B00100 solid 4px;
    border-top-left-radius: 9px;
    border-top-right-radius: 9px;
    background-color: white;
    padding: 7px 12% 0;
    box-shadow: 0 3px 8px rgba(50, 50, 50, 0.17);
  }

  .rails-default-error-page h1 {
    font-size: 100%;
    color: #730E15;
    line-height: 1.5em;
  }

  .rails-default-error-page div.dialog > p {
    margin: 0 0 1em;
    padding: 1em;
    background-color: #F7F7F7;
    border: 1px solid #CCC;
    border-right-color: #999;
    border-left-color: #999;
    border-bottom-color: #999;
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
    border-top-color: #DADADA;
    color: #666;
    box-shadow: 0 3px 8px rgba(50, 50, 50, 0.17);
  }
  </style>
</head>

<body class="rails-default-error-page">
  <!-- This file lives in public/500.html -->
  <div class="dialog">
    <div>
      <h1>We're sorry, but something went wrong.</h1>
    </div>
    <p>If you are the application owner check the logs for more information.</p>
  </div>
</body>
</html>

```

# public/422.html

```html
<!DOCTYPE html>
<html>
<head>
  <title>The change you wanted was rejected (422)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
  .rails-default-error-page {
    background-color: #EFEFEF;
    color: #2E2F30;
    text-align: center;
    font-family: arial, sans-serif;
    margin: 0;
  }

  .rails-default-error-page div.dialog {
    width: 95%;
    max-width: 33em;
    margin: 4em auto 0;
  }

  .rails-default-error-page div.dialog > div {
    border: 1px solid #CCC;
    border-right-color: #999;
    border-left-color: #999;
    border-bottom-color: #BBB;
    border-top: #B00100 solid 4px;
    border-top-left-radius: 9px;
    border-top-right-radius: 9px;
    background-color: white;
    padding: 7px 12% 0;
    box-shadow: 0 3px 8px rgba(50, 50, 50, 0.17);
  }

  .rails-default-error-page h1 {
    font-size: 100%;
    color: #730E15;
    line-height: 1.5em;
  }

  .rails-default-error-page div.dialog > p {
    margin: 0 0 1em;
    padding: 1em;
    background-color: #F7F7F7;
    border: 1px solid #CCC;
    border-right-color: #999;
    border-left-color: #999;
    border-bottom-color: #999;
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
    border-top-color: #DADADA;
    color: #666;
    box-shadow: 0 3px 8px rgba(50, 50, 50, 0.17);
  }
  </style>
</head>

<body class="rails-default-error-page">
  <!-- This file lives in public/422.html -->
  <div class="dialog">
    <div>
      <h1>The change you wanted was rejected.</h1>
      <p>Maybe you tried to change something you didn't have access to.</p>
    </div>
    <p>If you are the application owner check the logs for more information.</p>
  </div>
</body>
</html>

```

# public/404.html

```html
<!DOCTYPE html>
<html>
<head>
  <title>The page you were looking for doesn't exist (404)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
  .rails-default-error-page {
    background-color: #EFEFEF;
    color: #2E2F30;
    text-align: center;
    font-family: arial, sans-serif;
    margin: 0;
  }

  .rails-default-error-page div.dialog {
    width: 95%;
    max-width: 33em;
    margin: 4em auto 0;
  }

  .rails-default-error-page div.dialog > div {
    border: 1px solid #CCC;
    border-right-color: #999;
    border-left-color: #999;
    border-bottom-color: #BBB;
    border-top: #B00100 solid 4px;
    border-top-left-radius: 9px;
    border-top-right-radius: 9px;
    background-color: white;
    padding: 7px 12% 0;
    box-shadow: 0 3px 8px rgba(50, 50, 50, 0.17);
  }

  .rails-default-error-page h1 {
    font-size: 100%;
    color: #730E15;
    line-height: 1.5em;
  }

  .rails-default-error-page div.dialog > p {
    margin: 0 0 1em;
    padding: 1em;
    background-color: #F7F7F7;
    border: 1px solid #CCC;
    border-right-color: #999;
    border-left-color: #999;
    border-bottom-color: #999;
    border-bottom-left-radius: 4px;
    border-bottom-right-radius: 4px;
    border-top-color: #DADADA;
    color: #666;
    box-shadow: 0 3px 8px rgba(50, 50, 50, 0.17);
  }
  </style>
</head>

<body class="rails-default-error-page">
  <!-- This file lives in public/404.html -->
  <div class="dialog">
    <div>
      <h1>The page you were looking for doesn't exist.</h1>
      <p>You may have mistyped the address or the page may have moved.</p>
    </div>
    <p>If you are the application owner check the logs for more information.</p>
  </div>
</body>
</html>

```

# db/seeds.rb

```rb
# This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the bin/rails db:seed command (or created alongside the database with db:setup).
#
# Examples:
#
#   movies = Movie.create([{ name: "Star Wars" }, { name: "Lord of the Rings" }])
#   Character.create(name: "Luke", movie: movies.first)

```

# config/storage.yml

```yml
test:
  service: Disk
  root: <%= Rails.root.join("tmp/storage") %>

local:
  service: Disk
  root: <%= Rails.root.join("storage") %>

# Use bin/rails credentials:edit to set the AWS secrets (as aws:access_key_id|secret_access_key)
# amazon:
#   service: S3
#   access_key_id: <%= Rails.application.credentials.dig(:aws, :access_key_id) %>
#   secret_access_key: <%= Rails.application.credentials.dig(:aws, :secret_access_key) %>
#   region: us-east-1
#   bucket: your_own_bucket-<%= Rails.env %>

# Remember not to checkin your GCS keyfile to a repository
# google:
#   service: GCS
#   project: your_project
#   credentials: <%= Rails.root.join("path/to/gcs.keyfile") %>
#   bucket: your_own_bucket-<%= Rails.env %>

# Use bin/rails credentials:edit to set the Azure Storage secret (as azure_storage:storage_access_key)
# microsoft:
#   service: AzureStorage
#   storage_account_name: your_account_name
#   storage_access_key: <%= Rails.application.credentials.dig(:azure_storage, :storage_access_key) %>
#   container: your_container_name-<%= Rails.env %>

# mirror:
#   service: Mirror
#   primary: local
#   mirrors: [ amazon, google, microsoft ]

```

# config/routes.rb

```rb
Rails.application.routes.draw do
  # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html

  # Defines the root path route ("/")
  # root "articles#index"
end

```

# config/puma.rb

```rb
# Puma can serve each request in a thread from an internal thread pool.
# The `threads` method setting takes two numbers: a minimum and maximum.
# Any libraries that use thread pools should be configured to match
# the maximum value specified for Puma. Default is set to 5 threads for minimum
# and maximum; this matches the default thread size of Active Record.
#
max_threads_count = ENV.fetch("RAILS_MAX_THREADS") { 5 }
min_threads_count = ENV.fetch("RAILS_MIN_THREADS") { max_threads_count }
threads min_threads_count, max_threads_count

# Specifies the `worker_timeout` threshold that Puma will use to wait before
# terminating a worker in development environments.
#
worker_timeout 3600 if ENV.fetch("RAILS_ENV", "development") == "development"

# Specifies the `port` that Puma will listen on to receive requests; default is 3000.
#
port ENV.fetch("PORT") { 3000 }

# Specifies the `environment` that Puma will run in.
#
environment ENV.fetch("RAILS_ENV") { "development" }

# Specifies the `pidfile` that Puma will use.
pidfile ENV.fetch("PIDFILE") { "tmp/pids/server.pid" }

# Specifies the number of `workers` to boot in clustered mode.
# Workers are forked web server processes. If using threads and workers together
# the concurrency of the application would be max `threads` * `workers`.
# Workers do not work on JRuby or Windows (both of which do not support
# processes).
#
# workers ENV.fetch("WEB_CONCURRENCY") { 2 }

# Use the `preload_app!` method when specifying a `workers` number.
# This directive tells Puma to first boot the application and load code
# before forking the application. This takes advantage of Copy On Write
# process behavior so workers use less memory.
#
# preload_app!

# Allow puma to be restarted by `bin/rails restart` command.
plugin :tmp_restart

```

# config/importmap.rb

```rb
# Pin npm packages by running ./bin/importmap

pin "application", preload: true
pin "@hotwired/turbo-rails", to: "turbo.min.js", preload: true

```

# config/environment.rb

```rb
# Load the Rails application.
require_relative "application"

# Initialize the Rails application.
Rails.application.initialize!

```

# config/database.yml

```yml
# SQLite. Versions 3.8.0 and up are supported.
#   gem install sqlite3
#
#   Ensure the SQLite 3 gem is defined in your Gemfile
#   gem "sqlite3"
#
default: &default
  adapter: sqlite3
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  timeout: 5000

development:
  <<: *default
  database: db/development.sqlite3

# Warning: The database defined as "test" will be erased and
# re-generated from your development database when you run "rake".
# Do not set this db to the same as development or production.
test:
  <<: *default
  database: db/test.sqlite3

production:
  <<: *default
  database: db/production.sqlite3

```

# config/credentials.yml.enc

```enc
zRybEhBfXA8mLlx4AZw9DXJ+p7xcT7FcrEz5oMkQg70AByqrzNLrEMz0lbTwZbeCuHz/wfADJOG7+PHu7eQdcwPcECea+HdpsfczGEWwYyrlRaxMIhdYlk06MDt+ip544H78xynEqCSh6wjCyWnlOq99uFSxNbMzoNJcCVzhIa0RsvK6i9ZbgcgdJYRzn1Cd9TJ37aqefgVkS1FS7KyGDFjDxxqc4R/RwenCpK3Nr7s+OiGBcLIvO+HIblas14MjdXJraQJzkJ3Pij6aC8mE6P4RN9coxefBtWEkKsRqJ+m1SMvdG0+pGY9NiInnhGX3YXMJl3FDtaKxjajFo9iJu8tf6XmTQ81hiAAFFDJkL2HTqulP46Bjbf76eLVlJOH+3u8CUcb19l8xAAJhAEaZ2l59vvI/vctYzmWc--Sb+c1lxTGpJ6ui19--uT1P8R16CotcVu2TSO4Nvg==
```

# config/cable.yml

```yml
development:
  adapter: redis
  url: redis://localhost:6379/1

test:
  adapter: test

production:
  adapter: redis
  url: <%= ENV.fetch("REDIS_URL") { "redis://localhost:6379/1" } %>
  channel_prefix: interview_production

```

# config/boot.rb

```rb
ENV["BUNDLE_GEMFILE"] ||= File.expand_path("../Gemfile", __dir__)

require "bundler/setup" # Set up gems listed in the Gemfile.
require "bootsnap/setup" # Speed up boot time by caching expensive operations.

```

# config/application.rb

```rb
require_relative "boot"

require "rails/all"

# Require the gems listed in Gemfile, including any gems
# you've limited to :test, :development, or :production.
Bundler.require(*Rails.groups)

module Interview
  class Application < Rails::Application
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 7.1

    # Configuration for the application, engines, and railties goes here.
    #
    # These settings can be overridden in specific environments using the files
    # in config/environments, which are processed later.
    #
    # config.time_zone = "Central Time (US & Canada)"
    # config.eager_load_paths << Rails.root.join("extras")
  end
end

```

# docs/rails-layouts-and-rendering.md

```md
Layouts and Rendering in Rails

This guide covers the basic layout features of Action Controller and Action View.

After reading this guide, you will know:

    How to use the various rendering methods built into Rails.
    How to create layouts with multiple content sections.
    How to use partials to DRY up your views.
    How to use nested layouts (sub-templates).

Chapters

    Overview: How the Pieces Fit Together
    Creating Responses
        Rendering by Default: Convention Over Configuration in Action
        Using render
        Using redirect_to
        Using head to Build Header-Only Responses
    Structuring Layouts
        Asset Tag Helpers
        Understanding yield
        Using the content_for Method
        Using Partials
        Using Nested Layouts

1 Overview: How the Pieces Fit Together

This guide focuses on the interaction between Controller and View in the Model-View-Controller triangle. As you know, the Controller is responsible for orchestrating the whole process of handling a request in Rails, though it normally hands off any heavy code to the Model. But then, when it's time to send a response back to the user, the Controller hands things off to the View. It's that handoff that is the subject of this guide.

In broad strokes, this involves deciding what should be sent as the response and calling an appropriate method to create that response. If the response is a full-blown view, Rails also does some extra work to wrap the view in a layout and possibly to pull in partial views. You'll see all of those paths later in this guide.
2 Creating Responses

From the controller's point of view, there are three ways to create an HTTP response:

    Call render to create a full response to send back to the browser
    Call redirect_to to send an HTTP redirect status code to the browser
    Call head to create a response consisting solely of HTTP headers to send back to the browser

2.1 Rendering by Default: Convention Over Configuration in Action

You've heard that Rails promotes "convention over configuration". Default rendering is an excellent example of this. By default, controllers in Rails automatically render views with names that correspond to valid routes. For example, if you have this code in your BooksController class:

class BooksController < ApplicationController
end

And the following in your routes file:

resources :books

And you have a view file app/views/books/index.html.erb:

<h1>Books are coming soon!</h1>

Rails will automatically render app/views/books/index.html.erb when you navigate to /books and you will see "Books are coming soon!" on your screen.

However, a coming soon screen is only minimally useful, so you will soon create your Book model and add the index action to BooksController:

class BooksController < ApplicationController
  def index
    @books = Book.all
  end
end

Note that we don't have explicit render at the end of the index action in accordance with "convention over configuration" principle. The rule is that if you do not explicitly render something at the end of a controller action, Rails will automatically look for the action_name.html.erb template in the controller's view path and render it. So in this case, Rails will render the app/views/books/index.html.erb file.

If we want to display the properties of all the books in our view, we can do so with an ERB template like this:

<h1>Listing Books</h1>

<table>
  <thead>
    <tr>
      <th>Title</th>
      <th>Content</th>
      <th colspan="3"></th>
    </tr>
  </thead>

  <tbody>
    <% @books.each do |book| %>
      <tr>
        <td><%= book.title %></td>
        <td><%= book.content %></td>
        <td><%= link_to "Show", book %></td>
        <td><%= link_to "Edit", edit_book_path(book) %></td>
        <td><%= link_to "Destroy", book, data: { turbo_method: :delete, turbo_confirm: "Are you sure?" } %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<br>

<%= link_to "New book", new_book_path %>

The actual rendering is done by nested classes of the module ActionView::Template::Handlers. This guide does not dig into that process, but it's important to know that the file extension on your view controls the choice of template handler.
2.2 Using render

In most cases, the controller's render method does the heavy lifting of rendering your application's content for use by a browser. There are a variety of ways to customize the behavior of render. You can render the default view for a Rails template, or a specific template, or a file, or inline code, or nothing at all. You can render text, JSON, or XML. You can specify the content type or HTTP status of the rendered response as well.

If you want to see the exact results of a call to render without needing to inspect it in a browser, you can call render_to_string. This method takes exactly the same options as render, but it returns a string instead of sending a response back to the browser.
2.2.1 Rendering an Action's View

If you want to render the view that corresponds to a different template within the same controller, you can use render with the name of the view:

def update
  @book = Book.find(params[:id])
  if @book.update(book_params)
    redirect_to(@book)
  else
    render "edit"
  end
end

If the call to update fails, calling the update action in this controller will render the edit.html.erb template belonging to the same controller.

If you prefer, you can use a symbol instead of a string to specify the action to render:

def update
  @book = Book.find(params[:id])
  if @book.update(book_params)
    redirect_to(@book)
  else
    render :edit, status: :unprocessable_entity
  end
end

2.2.2 Rendering an Action's Template from Another Controller

What if you want to render a template from an entirely different controller from the one that contains the action code? You can also do that with render, which accepts the full path (relative to app/views) of the template to render. For example, if you're running code in an AdminProductsController that lives in app/controllers/admin, you can render the results of an action to a template in app/views/products this way:

render "products/show"

Rails knows that this view belongs to a different controller because of the embedded slash character in the string. If you want to be explicit, you can use the :template option (which was required on Rails 2.2 and earlier):

render template: "products/show"

2.2.3 Wrapping it up

The above two ways of rendering (rendering the template of another action in the same controller, and rendering the template of another action in a different controller) are actually variants of the same operation.

In fact, in the BooksController class, inside of the update action where we want to render the edit template if the book does not update successfully, all of the following render calls would all render the edit.html.erb template in the views/books directory:

render :edit
render action: :edit
render "edit"
render action: "edit"
render "books/edit"
render template: "books/edit"

Which one you use is really a matter of style and convention, but the rule of thumb is to use the simplest one that makes sense for the code you are writing.
2.2.4 Using render with :inline

The render method can do without a view completely, if you're willing to use the :inline option to supply ERB as part of the method call. This is perfectly valid:

render inline: "<% products.each do |p| %><p><%= p.name %></p><% end %>"

There is seldom any good reason to use this option. Mixing ERB into your controllers defeats the MVC orientation of Rails and will make it harder for other developers to follow the logic of your project. Use a separate erb view instead.

By default, inline rendering uses ERB. You can force it to use Builder instead with the :type option:

render inline: "xml.p {'Horrid coding practice!'}", type: :builder

2.2.5 Rendering Text

You can send plain text - with no markup at all - back to the browser by using the :plain option to render:

render plain: "OK"

Rendering pure text is most useful when you're responding to Ajax or web service requests that are expecting something other than proper HTML.

By default, if you use the :plain option, the text is rendered without using the current layout. If you want Rails to put the text into the current layout, you need to add the layout: true option and use the .text.erb extension for the layout file.
2.2.6 Rendering HTML

You can send an HTML string back to the browser by using the :html option to render:

render html: helpers.tag.strong('Not Found')

This is useful when you're rendering a small snippet of HTML code. However, you might want to consider moving it to a template file if the markup is complex.

When using html: option, HTML entities will be escaped if the string is not composed with html_safe-aware APIs.
2.2.7 Rendering JSON

JSON is a JavaScript data format used by many Ajax libraries. Rails has built-in support for converting objects to JSON and rendering that JSON back to the browser:

render json: @product

You don't need to call to_json on the object that you want to render. If you use the :json option, render will automatically call to_json for you.
2.2.8 Rendering XML

Rails also has built-in support for converting objects to XML and rendering that XML back to the caller:

render xml: @product

You don't need to call to_xml on the object that you want to render. If you use the :xml option, render will automatically call to_xml for you.
2.2.9 Rendering Vanilla JavaScript

Rails can render vanilla JavaScript:

render js: "alert('Hello Rails');"

This will send the supplied string to the browser with a MIME type of text/javascript.
2.2.10 Rendering Raw Body

You can send a raw content back to the browser, without setting any content type, by using the :body option to render:

render body: "raw"

This option should be used only if you don't care about the content type of the response. Using :plain or :html might be more appropriate most of the time.

Unless overridden, your response returned from this render option will be text/plain, as that is the default content type of Action Dispatch response.
2.2.11 Rendering Raw File

Rails can render a raw file from an absolute path. This is useful for conditionally rendering static files like error pages.

render file: "#{Rails.root}/public/404.html", layout: false

This renders the raw file (it doesn't support ERB or other handlers). By default it is rendered within the current layout.

Using the :file option in combination with users input can lead to security problems since an attacker could use this action to access security sensitive files in your file system.

send_file is often a faster and better option if a layout isn't required.
2.2.12 Rendering Objects

Rails can render objects responding to :render_in.

render MyRenderable.new

This calls render_in on the provided object with the current view context.

You can also provide the object by using the :renderable option to render:

render renderable: MyRenderable.new

2.2.13 Options for render

Calls to the render method generally accept six options:

    :content_type
    :layout
    :location
    :status
    :formats
    :variants

2.2.13.1 The :content_type Option

By default, Rails will serve the results of a rendering operation with the MIME content-type of text/html (or application/json if you use the :json option, or application/xml for the :xml option.). There are times when you might like to change this, and you can do so by setting the :content_type option:

render template: "feed", content_type: "application/rss"

2.2.13.2 The :layout Option

With most of the options to render, the rendered content is displayed as part of the current layout. You'll learn more about layouts and how to use them later in this guide.

You can use the :layout option to tell Rails to use a specific file as the layout for the current action:

render layout: "special_layout"

You can also tell Rails to render with no layout at all:

render layout: false

2.2.13.3 The :location Option

You can use the :location option to set the HTTP Location header:

render xml: photo, location: photo_url(photo)

2.2.13.4 The :status Option

Rails will automatically generate a response with the correct HTTP status code (in most cases, this is 200 OK). You can use the :status option to change this:

render status: 500
render status: :forbidden

Rails understands both numeric status codes and the corresponding symbols shown below.
Response Class 	HTTP Status Code 	Symbol
Informational 	100 	:continue
	101 	:switching_protocols
	102 	:processing
Success 	200 	:ok
	201 	:created
	202 	:accepted
	203 	:non_authoritative_information
	204 	:no_content
	205 	:reset_content
	206 	:partial_content
	207 	:multi_status
	208 	:already_reported
	226 	:im_used
Redirection 	300 	:multiple_choices
	301 	:moved_permanently
	302 	:found
	303 	:see_other
	304 	:not_modified
	305 	:use_proxy
	307 	:temporary_redirect
	308 	:permanent_redirect
Client Error 	400 	:bad_request
	401 	:unauthorized
	402 	:payment_required
	403 	:forbidden
	404 	:not_found
	405 	:method_not_allowed
	406 	:not_acceptable
	407 	:proxy_authentication_required
	408 	:request_timeout
	409 	:conflict
	410 	:gone
	411 	:length_required
	412 	:precondition_failed
	413 	:payload_too_large
	414 	:uri_too_long
	415 	:unsupported_media_type
	416 	:range_not_satisfiable
	417 	:expectation_failed
	421 	:misdirected_request
	422 	:unprocessable_entity
	423 	:locked
	424 	:failed_dependency
	426 	:upgrade_required
	428 	:precondition_required
	429 	:too_many_requests
	431 	:request_header_fields_too_large
	451 	:unavailable_for_legal_reasons
Server Error 	500 	:internal_server_error
	501 	:not_implemented
	502 	:bad_gateway
	503 	:service_unavailable
	504 	:gateway_timeout
	505 	:http_version_not_supported
	506 	:variant_also_negotiates
	507 	:insufficient_storage
	508 	:loop_detected
	510 	:not_extended
	511 	:network_authentication_required

If you try to render content along with a non-content status code (100-199, 204, 205, or 304), it will be dropped from the response.
2.2.13.5 The :formats Option

Rails uses the format specified in the request (or :html by default). You can change this passing the :formats option with a symbol or an array:

render formats: :xml
render formats: [:json, :xml]

If a template with the specified format does not exist an ActionView::MissingTemplate error is raised.
2.2.13.6 The :variants Option

This tells Rails to look for template variations of the same format. You can specify a list of variants by passing the :variants option with a symbol or an array.

An example of use would be this.

# called in HomeController#index
render variants: [:mobile, :desktop]

With this set of variants Rails will look for the following set of templates and use the first that exists.

    app/views/home/index.html+mobile.erb
    app/views/home/index.html+desktop.erb
    app/views/home/index.html.erb

If a template with the specified format does not exist an ActionView::MissingTemplate error is raised.

Instead of setting the variant on the render call you may also set it on the request object in your controller action.

def index
  request.variant = determine_variant
end

  private
    def determine_variant
      variant = nil
      # some code to determine the variant(s) to use
      variant = :mobile if session[:use_mobile]

      variant
    end

2.2.14 Finding Layouts

To find the current layout, Rails first looks for a file in app/views/layouts with the same base name as the controller. For example, rendering actions from the PhotosController class will use app/views/layouts/photos.html.erb (or app/views/layouts/photos.builder). If there is no such controller-specific layout, Rails will use app/views/layouts/application.html.erb or app/views/layouts/application.builder. If there is no .erb layout, Rails will use a .builder layout if one exists. Rails also provides several ways to more precisely assign specific layouts to individual controllers and actions.
2.2.14.1 Specifying Layouts for Controllers

You can override the default layout conventions in your controllers by using the layout declaration. For example:

class ProductsController < ApplicationController
  layout "inventory"
  #...
end

With this declaration, all of the views rendered by the ProductsController will use app/views/layouts/inventory.html.erb as their layout.

To assign a specific layout for the entire application, use a layout declaration in your ApplicationController class:

class ApplicationController < ActionController::Base
  layout "main"
  #...
end

With this declaration, all of the views in the entire application will use app/views/layouts/main.html.erb for their layout.
2.2.14.2 Choosing Layouts at Runtime

You can use a symbol to defer the choice of layout until a request is processed:

class ProductsController < ApplicationController
  layout :products_layout

  def show
    @product = Product.find(params[:id])
  end

  private
    def products_layout
      @current_user.special? ? "special" : "products"
    end
end

Now, if the current user is a special user, they'll get a special layout when viewing a product.

You can even use an inline method, such as a Proc, to determine the layout. For example, if you pass a Proc object, the block you give the Proc will be given the controller instance, so the layout can be determined based on the current request:

class ProductsController < ApplicationController
  layout Proc.new { |controller| controller.request.xhr? ? "popup" : "application" }
end

2.2.14.3 Conditional Layouts

Layouts specified at the controller level support the :only and :except options. These options take either a method name, or an array of method names, corresponding to method names within the controller:

class ProductsController < ApplicationController
  layout "product", except: [:index, :rss]
end

With this declaration, the product layout would be used for everything but the rss and index methods.
2.2.14.4 Layout Inheritance

Layout declarations cascade downward in the hierarchy, and more specific layout declarations always override more general ones. For example:

    application_controller.rb

    class ApplicationController < ActionController::Base
      layout "main"
    end

articles_controller.rb

class ArticlesController < ApplicationController
end

special_articles_controller.rb

class SpecialArticlesController < ArticlesController
  layout "special"
end

old_articles_controller.rb

class OldArticlesController < SpecialArticlesController
  layout false

  def show
    @article = Article.find(params[:id])
  end

  def index
    @old_articles = Article.older
    render layout: "old"
  end
  # ...
end

In this application:

    In general, views will be rendered in the main layout
    ArticlesController#index will use the main layout
    SpecialArticlesController#index will use the special layout
    OldArticlesController#show will use no layout at all
    OldArticlesController#index will use the old layout

2.2.14.5 Template Inheritance

Similar to the Layout Inheritance logic, if a template or partial is not found in the conventional path, the controller will look for a template or partial to render in its inheritance chain. For example:

# app/controllers/application_controller.rb
class ApplicationController < ActionController::Base
end

# app/controllers/admin_controller.rb
class AdminController < ApplicationController
end

# app/controllers/admin/products_controller.rb
class Admin::ProductsController < AdminController
  def index
  end
end

The lookup order for an admin/products#index action will be:

    app/views/admin/products/
    app/views/admin/
    app/views/application/

This makes app/views/application/ a great place for your shared partials, which can then be rendered in your ERB as such:

<%# app/views/admin/products/index.html.erb %>
<%= render @products || "empty_list" %>

<%# app/views/application/_empty_list.html.erb %>
There are no items in this list <em>yet</em>.

2.2.15 Avoiding Double Render Errors

Sooner or later, most Rails developers will see the error message "Can only render or redirect once per action". While this is annoying, it's relatively easy to fix. Usually it happens because of a fundamental misunderstanding of the way that render works.

For example, here's some code that will trigger this error:

def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show"
  end
  render action: "regular_show"
end

If @book.special? evaluates to true, Rails will start the rendering process to dump the @book variable into the special_show view. But this will not stop the rest of the code in the show action from running, and when Rails hits the end of the action, it will start to render the regular_show view - and throw an error. The solution is simple: make sure that you have only one call to render or redirect in a single code path. One thing that can help is return. Here's a patched version of the method:

def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show"
    return
  end
  render action: "regular_show"
end

Note that the implicit render done by ActionController detects if render has been called, so the following will work without errors:

def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show"
  end
end

This will render a book with special? set with the special_show template, while other books will render with the default show template.
2.3 Using redirect_to

Another way to handle returning responses to an HTTP request is with redirect_to. As you've seen, render tells Rails which view (or other asset) to use in constructing a response. The redirect_to method does something completely different: it tells the browser to send a new request for a different URL. For example, you could redirect from wherever you are in your code to the index of photos in your application with this call:

redirect_to photos_url

You can use redirect_back to return the user to the page they just came from. This location is pulled from the HTTP_REFERER header which is not guaranteed to be set by the browser, so you must provide the fallback_location to use in this case.

redirect_back(fallback_location: root_path)

redirect_to and redirect_back do not halt and return immediately from method execution, but simply set HTTP responses. Statements occurring after them in a method will be executed. You can halt by an explicit return or some other halting mechanism, if needed.
2.3.1 Getting a Different Redirect Status Code

Rails uses HTTP status code 302, a temporary redirect, when you call redirect_to. If you'd like to use a different status code, perhaps 301, a permanent redirect, you can use the :status option:

redirect_to photos_path, status: 301

Just like the :status option for render, :status for redirect_to accepts both numeric and symbolic header designations.
2.3.2 The Difference Between render and redirect_to

Sometimes inexperienced developers think of redirect_to as a sort of goto command, moving execution from one place to another in your Rails code. This is not correct. Your code stops running and waits for a new request from the browser. It just happens that you've told the browser what request it should make next, by sending back an HTTP 302 status code.

Consider these actions to see the difference:

def index
  @books = Book.all
end

def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    render action: "index"
  end
end

With the code in this form, there will likely be a problem if the @book variable is nil. Remember, a render :action doesn't run any code in the target action, so nothing will set up the @books variable that the index view will probably require. One way to fix this is to redirect instead of rendering:

def index
  @books = Book.all
end

def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    redirect_to action: :index
  end
end

With this code, the browser will make a fresh request for the index page, the code in the index method will run, and all will be well.

The only downside to this code is that it requires a round trip to the browser: the browser requested the show action with /books/1 and the controller finds that there are no books, so the controller sends out a 302 redirect response to the browser telling it to go to /books/, the browser complies and sends a new request back to the controller asking now for the index action, the controller then gets all the books in the database and renders the index template, sending it back down to the browser which then shows it on your screen.

While in a small application, this added latency might not be a problem, it is something to think about if response time is a concern. We can demonstrate one way to handle this with a contrived example:

def index
  @books = Book.all
end

def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    @books = Book.all
    flash.now[:alert] = "Your book was not found"
    render "index"
  end
end

This would detect that there are no books with the specified ID, populate the @books instance variable with all the books in the model, and then directly render the index.html.erb template, returning it to the browser with a flash alert message to tell the user what happened.
2.4 Using head to Build Header-Only Responses

The head method can be used to send responses with only headers to the browser. The head method accepts a number or symbol (see reference table) representing an HTTP status code. The options argument is interpreted as a hash of header names and values. For example, you can return only an error header:

head :bad_request

This would produce the following header:

HTTP/1.1 400 Bad Request
Connection: close
Date: Sun, 24 Jan 2010 12:15:53 GMT
Transfer-Encoding: chunked
Content-Type: text/html; charset=utf-8
X-Runtime: 0.013483
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache

Or you can use other HTTP headers to convey other information:

head :created, location: photo_path(@photo)

Which would produce:

HTTP/1.1 201 Created
Connection: close
Date: Sun, 24 Jan 2010 12:16:44 GMT
Transfer-Encoding: chunked
Location: /photos/1
Content-Type: text/html; charset=utf-8
X-Runtime: 0.083496
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache

3 Structuring Layouts

When Rails renders a view as a response, it does so by combining the view with the current layout, using the rules for finding the current layout that were covered earlier in this guide. Within a layout, you have access to three tools for combining different bits of output to form the overall response:

    Asset tags
    yield and content_for
    Partials

3.1 Asset Tag Helpers

Asset tag helpers provide methods for generating HTML that link views to feeds, JavaScript, stylesheets, images, videos, and audios. There are six asset tag helpers available in Rails:

    auto_discovery_link_tag
    javascript_include_tag
    stylesheet_link_tag
    image_tag
    video_tag
    audio_tag

You can use these tags in layouts or other views, although the auto_discovery_link_tag, javascript_include_tag, and stylesheet_link_tag, are most commonly used in the <head> section of a layout.

The asset tag helpers do not verify the existence of the assets at the specified locations; they simply assume that you know what you're doing and generate the link.
3.1.1 Linking to Feeds with the auto_discovery_link_tag

The auto_discovery_link_tag helper builds HTML that most browsers and feed readers can use to detect the presence of RSS, Atom, or JSON feeds. It takes the type of the link (:rss, :atom, or :json), a hash of options that are passed through to url_for, and a hash of options for the tag:

<%= auto_discovery_link_tag(:rss, {action: "feed"},
  {title: "RSS Feed"}) %>

There are three tag options available for the auto_discovery_link_tag:

    :rel specifies the rel value in the link. The default value is "alternate".
    :type specifies an explicit MIME type. Rails will generate an appropriate MIME type automatically.
    :title specifies the title of the link. The default value is the uppercase :type value, for example, "ATOM" or "RSS".

3.1.2 Linking to JavaScript Files with the javascript_include_tag

The javascript_include_tag helper returns an HTML script tag for each source provided.

If you are using Rails with the Asset Pipeline enabled, this helper will generate a link to /assets/javascripts/ rather than public/javascripts which was used in earlier versions of Rails. This link is then served by the asset pipeline.

A JavaScript file within a Rails application or Rails engine goes in one of three locations: app/assets, lib/assets or vendor/assets. These locations are explained in detail in the Asset Organization section in the Asset Pipeline Guide.

You can specify a full path relative to the document root, or a URL, if you prefer. For example, to link to a JavaScript file that is inside a directory called javascripts inside of one of app/assets, lib/assets or vendor/assets, you would do this:

<%= javascript_include_tag "main" %>

Rails will then output a script tag such as this:

<script src='/assets/main.js'></script>

The request to this asset is then served by the Sprockets gem.

To include multiple files such as app/assets/javascripts/main.js and app/assets/javascripts/columns.js at the same time:

<%= javascript_include_tag "main", "columns" %>

To include app/assets/javascripts/main.js and app/assets/javascripts/photos/columns.js:

<%= javascript_include_tag "main", "/photos/columns" %>

To include http://example.com/main.js:

<%= javascript_include_tag "http://example.com/main.js" %>

3.1.3 Linking to CSS Files with the stylesheet_link_tag

The stylesheet_link_tag helper returns an HTML <link> tag for each source provided.

If you are using Rails with the "Asset Pipeline" enabled, this helper will generate a link to /assets/stylesheets/. This link is then processed by the Sprockets gem. A stylesheet file can be stored in one of three locations: app/assets, lib/assets, or vendor/assets.

You can specify a full path relative to the document root, or a URL. For example, to link to a stylesheet file that is inside a directory called stylesheets inside of one of app/assets, lib/assets, or vendor/assets, you would do this:

<%= stylesheet_link_tag "main" %>

To include app/assets/stylesheets/main.css and app/assets/stylesheets/columns.css:

<%= stylesheet_link_tag "main", "columns" %>

To include app/assets/stylesheets/main.css and app/assets/stylesheets/photos/columns.css:

<%= stylesheet_link_tag "main", "photos/columns" %>

To include http://example.com/main.css:

<%= stylesheet_link_tag "http://example.com/main.css" %>

By default, the stylesheet_link_tag creates links with rel="stylesheet". You can override this default by specifying an appropriate option (:rel):

<%= stylesheet_link_tag "main_print", media: "print" %>

3.1.4 Linking to Images with the image_tag

The image_tag helper builds an HTML <img /> tag to the specified file. By default, files are loaded from public/images.

Note that you must specify the extension of the image.

<%= image_tag "header.png" %>

You can supply a path to the image if you like:

<%= image_tag "icons/delete.gif" %>

You can supply a hash of additional HTML options:

<%= image_tag "icons/delete.gif", {height: 45} %>

You can supply alternate text for the image which will be used if the user has images turned off in their browser. If you do not specify an alt text explicitly, it defaults to the file name of the file, capitalized and with no extension. For example, these two image tags would return the same code:

<%= image_tag "home.gif" %>
<%= image_tag "home.gif", alt: "Home" %>

You can also specify a special size tag, in the format "{width}x{height}":

<%= image_tag "home.gif", size: "50x20" %>

In addition to the above special tags, you can supply a final hash of standard HTML options, such as :class, :id, or :name:

<%= image_tag "home.gif", alt: "Go Home",
                          id: "HomeImage",
                          class: "nav_bar" %>

3.1.5 Linking to Videos with the video_tag

The video_tag helper builds an HTML5 <video> tag to the specified file. By default, files are loaded from public/videos.

<%= video_tag "movie.ogg" %>

Produces

<video src="/videos/movie.ogg" />

Like an image_tag you can supply a path, either absolute, or relative to the public/videos directory. Additionally you can specify the size: "#{width}x#{height}" option just like an image_tag. Video tags can also have any of the HTML options specified at the end (id, class et al).

The video tag also supports all of the <video> HTML options through the HTML options hash, including:

    poster: "image_name.png", provides an image to put in place of the video before it starts playing.
    autoplay: true, starts playing the video on page load.
    loop: true, loops the video once it gets to the end.
    controls: true, provides browser supplied controls for the user to interact with the video.
    autobuffer: true, the video will pre load the file for the user on page load.

You can also specify multiple videos to play by passing an array of videos to the video_tag:

<%= video_tag ["trailer.ogg", "movie.ogg"] %>

This will produce:

<video>
  <source src="/videos/trailer.ogg">
  <source src="/videos/movie.ogg">
</video>

3.1.6 Linking to Audio Files with the audio_tag

The audio_tag helper builds an HTML5 <audio> tag to the specified file. By default, files are loaded from public/audios.

<%= audio_tag "music.mp3" %>

You can supply a path to the audio file if you like:

<%= audio_tag "music/first_song.mp3" %>

You can also supply a hash of additional options, such as :id, :class, etc.

Like the video_tag, the audio_tag has special options:

    autoplay: true, starts playing the audio on page load
    controls: true, provides browser supplied controls for the user to interact with the audio.
    autobuffer: true, the audio will pre load the file for the user on page load.

3.2 Understanding yield

Within the context of a layout, yield identifies a section where content from the view should be inserted. The simplest way to use this is to have a single yield, into which the entire contents of the view currently being rendered is inserted:

<html>
  <head>
  </head>
  <body>
  <%= yield %>
  </body>
</html>

You can also create a layout with multiple yielding regions:

<html>
  <head>
  <%= yield :head %>
  </head>
  <body>
  <%= yield %>
  </body>
</html>

The main body of the view will always render into the unnamed yield. To render content into a named yield, you use the content_for method.
3.3 Using the content_for Method

The content_for method allows you to insert content into a named yield block in your layout. For example, this view would work with the layout that you just saw:

<% content_for :head do %>
  <title>A simple page</title>
<% end %>

<p>Hello, Rails!</p>

The result of rendering this page into the supplied layout would be this HTML:

<html>
  <head>
  <title>A simple page</title>
  </head>
  <body>
  <p>Hello, Rails!</p>
  </body>
</html>

The content_for method is very helpful when your layout contains distinct regions such as sidebars and footers that should get their own blocks of content inserted. It's also useful for inserting tags that load page-specific JavaScript or CSS files into the header of an otherwise generic layout.
3.4 Using Partials

Partial templates - usually just called "partials" - are another device for breaking the rendering process into more manageable chunks. With a partial, you can move the code for rendering a particular piece of a response to its own file.
3.4.1 Naming Partials

To render a partial as part of a view, you use the render method within the view:

<%= render "menu" %>

This will render a file named _menu.html.erb at that point within the view being rendered. Note the leading underscore character: partials are named with a leading underscore to distinguish them from regular views, even though they are referred to without the underscore. This holds true even when you're pulling in a partial from another folder:

<%= render "application/menu" %>

Since view partials rely on the same Template Inheritance as templates and layouts, that code will pull in the partial from app/views/application/_menu.html.erb.
3.4.2 Using Partials to Simplify Views

One way to use partials is to treat them as the equivalent of subroutines: as a way to move details out of a view so that you can grasp what's going on more easily. For example, you might have a view that looked like this:

<%= render "application/ad_banner" %>

<h1>Products</h1>

<p>Here are a few of our fine products:</p>
<%# ... %>

<%= render "application/footer" %>

Here, the _ad_banner.html.erb and _footer.html.erb partials could contain content that is shared by many pages in your application. You don't need to see the details of these sections when you're concentrating on a particular page.

As seen in the previous sections of this guide, yield is a very powerful tool for cleaning up your layouts. Keep in mind that it's pure Ruby, so you can use it almost everywhere. For example, we can use it to DRY up form layout definitions for several similar resources:

    users/index.html.erb

    <%= render "application/search_filters", search: @q do |form| %>
      <p>
        Name contains: <%= form.text_field :name_contains %>
      </p>
    <% end %>

roles/index.html.erb

<%= render "application/search_filters", search: @q do |form| %>
  <p>
    Title contains: <%= form.text_field :title_contains %>
  </p>
<% end %>

application/_search_filters.html.erb

<%= form_with model: search do |form| %>
  <h1>Search form:</h1>
  <fieldset>
    <%= yield form %>
  </fieldset>
  <p>
    <%= form.submit "Search" %>
  </p>
<% end %>

For content that is shared among all pages in your application, you can use partials directly from layouts.
3.4.3 Partial Layouts

A partial can use its own layout file, just as a view can use a layout. For example, you might call a partial like this:

<%= render partial: "link_area", layout: "graybar" %>

This would look for a partial named _link_area.html.erb and render it using the layout _graybar.html.erb. Note that layouts for partials follow the same leading-underscore naming as regular partials, and are placed in the same folder with the partial that they belong to (not in the master layouts folder).

Also note that explicitly specifying :partial is required when passing additional options such as :layout.
3.4.4 Passing Local Variables

You can also pass local variables into partials, making them even more powerful and flexible. For example, you can use this technique to reduce duplication between new and edit pages, while still keeping a bit of distinct content:

    new.html.erb

    <h1>New zone</h1>
    <%= render partial: "form", locals: {zone: @zone} %>

edit.html.erb

<h1>Editing zone</h1>
<%= render partial: "form", locals: {zone: @zone} %>

_form.html.erb

<%= form_with model: zone do |form| %>
  <p>
    <b>Zone name</b><br>
    <%= form.text_field :name %>
  </p>
  <p>
    <%= form.submit %>
  </p>
<% end %>

Although the same partial will be rendered into both views, Action View's submit helper will return "Create Zone" for the new action and "Update Zone" for the edit action.

To pass a local variable to a partial in only specific cases use the local_assigns.

    index.html.erb

    <%= render user.articles %>

show.html.erb

<%= render article, full: true %>

_article.html.erb

<h2><%= article.title %></h2>

<% if local_assigns[:full] %>
  <%= simple_format article.body %>
<% else %>
  <%= truncate article.body %>
<% end %>

This way it is possible to use the partial without the need to declare all local variables.

Every partial also has a local variable with the same name as the partial (minus the leading underscore). You can pass an object in to this local variable via the :object option:

<%= render partial: "customer", object: @new_customer %>

Within the customer partial, the customer variable will refer to @new_customer from the parent view.

If you have an instance of a model to render into a partial, you can use a shorthand syntax:

<%= render @customer %>

Assuming that the @customer instance variable contains an instance of the Customer model, this will use _customer.html.erb to render it and will pass the local variable customer into the partial which will refer to the @customer instance variable in the parent view.
3.4.5 Rendering Collections

Partials are very useful in rendering collections. When you pass a collection to a partial via the :collection option, the partial will be inserted once for each member in the collection:

    index.html.erb

    <h1>Products</h1>
    <%= render partial: "product", collection: @products %>

_product.html.erb

<p>Product Name: <%= product.name %></p>

When a partial is called with a pluralized collection, then the individual instances of the partial have access to the member of the collection being rendered via a variable named after the partial. In this case, the partial is _product, and within the _product partial, you can refer to product to get the instance that is being rendered.

There is also a shorthand for this. Assuming @products is a collection of Product instances, you can simply write this in the index.html.erb to produce the same result:

<h1>Products</h1>
<%= render @products %>

Rails determines the name of the partial to use by looking at the model name in the collection. In fact, you can even create a heterogeneous collection and render it this way, and Rails will choose the proper partial for each member of the collection:

    index.html.erb

    <h1>Contacts</h1>
    <%= render [customer1, employee1, customer2, employee2] %>

customers/_customer.html.erb

<p>Customer: <%= customer.name %></p>

employees/_employee.html.erb

<p>Employee: <%= employee.name %></p>

In this case, Rails will use the customer or employee partials as appropriate for each member of the collection.

In the event that the collection is empty, render will return nil, so it should be fairly simple to provide alternative content.

<h1>Products</h1>
<%= render(@products) || "There are no products available." %>

3.4.6 Local Variables

To use a custom local variable name within the partial, specify the :as option in the call to the partial:

<%= render partial: "product", collection: @products, as: :item %>

With this change, you can access an instance of the @products collection as the item local variable within the partial.

You can also pass in arbitrary local variables to any partial you are rendering with the locals: {} option:

<%= render partial: "product", collection: @products,
           as: :item, locals: {title: "Products Page"} %>

In this case, the partial will have access to a local variable title with the value "Products Page".
3.4.7 Counter Variables

Rails also makes a counter variable available within a partial called by the collection. The variable is named after the title of the partial followed by _counter. For example, when rendering a collection @products the partial _product.html.erb can access the variable product_counter. The variable indexes the number of times the partial has been rendered within the enclosing view, starting with a value of 0 on the first render.

# index.html.erb
<%= render partial: "product", collection: @products %>

# _product.html.erb
<%= product_counter %> # 0 for the first product, 1 for the second product...

This also works when the partial name is changed using the as: option. So if you did as: :item, the counter variable would be item_counter.
3.4.8 Spacer Templates

You can also specify a second partial to be rendered between instances of the main partial by using the :spacer_template option:

<%= render partial: @products, spacer_template: "product_ruler" %>

Rails will render the _product_ruler partial (with no data passed in to it) between each pair of _product partials.
3.4.9 Collection Partial Layouts

When rendering collections it is also possible to use the :layout option:

<%= render partial: "product", collection: @products, layout: "special_layout" %>

The layout will be rendered together with the partial for each item in the collection. The current object and object_counter variables will be available in the layout as well, the same way they are within the partial.
3.5 Using Nested Layouts

You may find that your application requires a layout that differs slightly from your regular application layout to support one particular controller. Rather than repeating the main layout and editing it, you can accomplish this by using nested layouts (sometimes called sub-templates). Here's an example:

Suppose you have the following ApplicationController layout:

    app/views/layouts/application.html.erb

    <html>
    <head>
      <title><%= @page_title or "Page Title" %></title>
      <%= stylesheet_link_tag "layout" %>
      <style><%= yield :stylesheets %></style>
    </head>
    <body>
      <div id="top_menu">Top menu items here</div>
      <div id="menu">Menu items here</div>
      <div id="content"><%= content_for?(:content) ? yield(:content) : yield %></div>
    </body>
    </html>

On pages generated by NewsController, you want to hide the top menu and add a right menu:

    app/views/layouts/news.html.erb

    <% content_for :stylesheets do %>
      #top_menu {display: none}
      #right_menu {float: right; background-color: yellow; color: black}
    <% end %>
    <% content_for :content do %>
      <div id="right_menu">Right menu items here</div>
      <%= content_for?(:news_content) ? yield(:news_content) : yield %>
    <% end %>
    <%= render template: "layouts/application" %>

That's it. The News views will use the new layout, hiding the top menu and adding a new right menu inside the "content" div.

There are several ways of getting similar results with different sub-templating schemes using this technique. Note that there is no limit in nesting levels. One can use the ActionView::render method via render template: 'layouts/news' to base a new layout on the News layout. If you are sure you will not subtemplate the News layout, you can replace the content_for?(:news_content) ? yield(:news_content) : yield with simply yield.
Feedback

You're encouraged to help improve the quality of this guide.

Please contribute if you see any typos or factual errors. To get started, you can read our documentation contributions section.

You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for main. Make sure to check Edge Guides first to verify if the issues are already fixed or not on the main branch. Check the Ruby on Rails Guides Guidelines for style and conventions.

If for whatever reason you spot something to fix but cannot patch it yourself, please open an issue.

And last but not least, any kind of discussion regarding Ruby on Rails documentation is very welcome on the official Ruby on Rails Forum.

This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License

"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.

```

# docs/rails-active-record.md

```md
Active Record Basics

This guide is an introduction to Active Record.

After reading this guide, you will know:

    What Object Relational Mapping and Active Record are and how they are used in Rails.
    How Active Record fits into the Model-View-Controller paradigm.
    How to use Active Record models to manipulate data stored in a relational database.
    Active Record schema naming conventions.
    The concepts of database migrations, validations, callbacks, and associations.

Chapters

    What is Active Record?
        The Active Record Pattern
        Object Relational Mapping
        Active Record as an ORM Framework
    Convention over Configuration in Active Record
        Naming Conventions
        Schema Conventions
    Creating Active Record Models
    Overriding the Naming Conventions
    CRUD: Reading and Writing Data
        Create
        Read
        Update
        Delete
    Validations
    Callbacks
    Migrations
    Associations

1 What is Active Record?

Active Record is the M in MVC - the model - which is the layer of the system responsible for representing business data and logic. Active Record facilitates the creation and use of business objects whose data requires persistent storage to a database. It is an implementation of the Active Record pattern which itself is a description of an Object Relational Mapping system.
1.1 The Active Record Pattern

Active Record was described by Martin Fowler in his book Patterns of Enterprise Application Architecture. In Active Record, objects carry both persistent data and behavior which operates on that data. Active Record takes the opinion that ensuring data access logic as part of the object will educate users of that object on how to write to and read from the database.
1.2 Object Relational Mapping

Object Relational Mapping, commonly referred to as its abbreviation ORM, is a technique that connects the rich objects of an application to tables in a relational database management system. Using ORM, the properties and relationships of the objects in an application can be easily stored and retrieved from a database without writing SQL statements directly and with less overall database access code.

Basic knowledge of relational database management systems (RDBMS) and structured query language (SQL) is helpful in order to fully understand Active Record. Please refer to this tutorial (or this one) or study them by other means if you would like to learn more.
1.3 Active Record as an ORM Framework

Active Record gives us several mechanisms, the most important being the ability to:

    Represent models and their data.
    Represent associations between these models.
    Represent inheritance hierarchies through related models.
    Validate models before they get persisted to the database.
    Perform database operations in an object-oriented fashion.

2 Convention over Configuration in Active Record

When writing applications using other programming languages or frameworks, it may be necessary to write a lot of configuration code. This is particularly true for ORM frameworks in general. However, if you follow the conventions adopted by Rails, you'll need to write very little configuration (in some cases no configuration at all) when creating Active Record models. The idea is that if you configure your applications in the very same way most of the time then this should be the default way. Thus, explicit configuration would be needed only in those cases where you can't follow the standard convention.
2.1 Naming Conventions

By default, Active Record uses some naming conventions to find out how the mapping between models and database tables should be created. Rails will pluralize your class names to find the respective database table. So, for a class Book, you should have a database table called books. The Rails pluralization mechanisms are very powerful, being capable of pluralizing (and singularizing) both regular and irregular words. When using class names composed of two or more words, the model class name should follow the Ruby conventions, using the CamelCase form, while the table name must use the snake_case form. Examples:

    Model Class - Singular with the first letter of each word capitalized (e.g., BookClub).
    Database Table - Plural with underscores separating words (e.g., book_clubs).

Model / Class 	Table / Schema
Article 	articles
LineItem 	line_items
Deer 	deers
Mouse 	mice
Person 	people
2.2 Schema Conventions

Active Record uses naming conventions for the columns in database tables, depending on the purpose of these columns.

    Foreign keys - These fields should be named following the pattern singularized_table_name_id (e.g., item_id, order_id). These are the fields that Active Record will look for when you create associations between your models.
    Primary keys - By default, Active Record will use an integer column named id as the table's primary key (bigint for PostgreSQL and MySQL, integer for SQLite). When using Active Record Migrations to create your tables, this column will be automatically created.

There are also some optional column names that will add additional features to Active Record instances:

    created_at - Automatically gets set to the current date and time when the record is first created.
    updated_at - Automatically gets set to the current date and time whenever the record is created or updated.
    lock_version - Adds optimistic locking to a model.
    type - Specifies that the model uses Single Table Inheritance.
    (association_name)_type - Stores the type for polymorphic associations.
    (table_name)_count - Used to cache the number of belonging objects on associations. For example, a comments_count column in an Article class that has many instances of Comment will cache the number of existent comments for each article.

While these column names are optional, they are in fact reserved by Active Record. Steer clear of reserved keywords unless you want the extra functionality. For example, type is a reserved keyword used to designate a table using Single Table Inheritance (STI). If you are not using STI, try an analogous keyword like "context", that may still accurately describe the data you are modeling.
3 Creating Active Record Models

When generating an application, an abstract ApplicationRecord class will be created in app/models/application_record.rb. This is the base class for all models in an app, and it's what turns a regular ruby class into an Active Record model.

To create Active Record models, subclass the ApplicationRecord class and you're good to go:

class Product < ApplicationRecord
end

This will create a Product model, mapped to a products table at the database. By doing this you'll also have the ability to map the columns of each row in that table with the attributes of the instances of your model. Suppose that the products table was created using an SQL (or one of its extensions) statement like:

CREATE TABLE products (
  id int(11) NOT NULL auto_increment,
  name varchar(255),
  PRIMARY KEY  (id)
);

The schema above declares a table with two columns: id and name. Each row of this table represents a certain product with these two parameters. Thus, you would be able to write code like the following:

p = Product.new
p.name = "Some Book"
puts p.name # "Some Book"

4 Overriding the Naming Conventions

What if you need to follow a different naming convention or need to use your Rails application with a legacy database? No problem, you can easily override the default conventions.

Since ApplicationRecord inherits from ActiveRecord::Base, your application's models will have a number of helpful methods available to them. For example, you can use the ActiveRecord::Base.table_name= method to customize the table name that should be used:

class Product < ApplicationRecord
  self.table_name = "my_products"
end

If you do so, you will have to manually define the class name that is hosting the fixtures (my_products.yml) using the set_fixture_class method in your test definition:

# test/models/product_test.rb
class ProductTest < ActiveSupport::TestCase
  set_fixture_class my_products: Product
  fixtures :my_products
  # ...
end

It's also possible to override the column that should be used as the table's primary key using the ActiveRecord::Base.primary_key= method:

class Product < ApplicationRecord
  self.primary_key = "product_id"
end

Active Record does not recommend using non-primary key columns named id. Using a column named id which is not a single-column primary key complicates the access to the column value. The application will have to use the id_value alias attribute to access the value of the non-PK id column.

If you try to create a column named id which is not the primary key, Rails will throw an error during migrations such as: you can't redefine the primary key column 'id' on 'my_products'. To define a custom primary key, pass { id: false } to create_table.
5 CRUD: Reading and Writing Data

CRUD is an acronym for the four verbs we use to operate on data: Create, Read, Update and Delete. Active Record automatically creates methods to allow an application to read and manipulate data stored within its tables.
5.1 Create

Active Record objects can be created from a hash, a block, or have their attributes manually set after creation. The new method will return a new object while create will return the object and save it to the database.

For example, given a model User with attributes of name and occupation, the create method call will create and save a new record into the database:

user = User.create(name: "David", occupation: "Code Artist")

Using the new method, an object can be instantiated without being saved:

user = User.new
user.name = "David"
user.occupation = "Code Artist"

A call to user.save will commit the record to the database.

Finally, if a block is provided, both create and new will yield the new object to that block for initialization, while only create will persist the resulting object to the database:

user = User.new do |u|
  u.name = "David"
  u.occupation = "Code Artist"
end

5.2 Read

Active Record provides a rich API for accessing data within a database. Below are a few examples of different data access methods provided by Active Record.

# return a collection with all users
users = User.all

# return the first user
user = User.first

# return the first user named David
david = User.find_by(name: 'David')

# find all users named David who are Code Artists and sort by created_at in reverse chronological order
users = User.where(name: 'David', occupation: 'Code Artist').order(created_at: :desc)

You can learn more about querying an Active Record model in the Active Record Query Interface guide.
5.3 Update

Once an Active Record object has been retrieved, its attributes can be modified and it can be saved to the database.

user = User.find_by(name: 'David')
user.name = 'Dave'
user.save

A shorthand for this is to use a hash mapping attribute names to the desired value, like so:

user = User.find_by(name: 'David')
user.update(name: 'Dave')

This is most useful when updating several attributes at once.

If you'd like to update several records in bulk without callbacks or validations, you can update the database directly using update_all:

User.update_all max_login_attempts: 3, must_change_password: true

5.4 Delete

Likewise, once retrieved, an Active Record object can be destroyed, which removes it from the database.

user = User.find_by(name: 'David')
user.destroy

If you'd like to delete several records in bulk, you may use destroy_by or destroy_all method:

# find and delete all users named David
User.destroy_by(name: 'David')

# delete all users
User.destroy_all

6 Validations

Active Record allows you to validate the state of a model before it gets written into the database. There are several methods that you can use to check your models and validate that an attribute value is not empty, is unique and not already in the database, follows a specific format, and many more.

Methods like save, create and update validate a model before persisting it to the database. When a model is invalid these methods return false and no database operations are performed. All of these methods have a bang counterpart (that is, save!, create! and update!), which are stricter in that they raise an ActiveRecord::RecordInvalid exception when validation fails. A quick example to illustrate:

class User < ApplicationRecord
  validates :name, presence: true
end

irb> user = User.new
irb> user.save
=> false
irb> user.save!
ActiveRecord::RecordInvalid: Validation failed: Name can't be blank

You can learn more about validations in the Active Record Validations guide.
7 Callbacks

Active Record callbacks allow you to attach code to certain events in the life-cycle of your models. This enables you to add behavior to your models by transparently executing code when those events occur, like when you create a new record, update it, destroy it, and so on.

class User < ApplicationRecord
  after_create :log_new_user

  private
    def log_new_user
      puts "A new user was registered"
    end
end

irb> @user = User.create
A new user was registered

You can learn more about callbacks in the Active Record Callbacks guide.
8 Migrations

Rails provides a convenient way to manage changes to a database schema via migrations. Migrations are written in a domain-specific language and stored in files which are executed against any database that Active Record supports.

Here's a migration that creates a new table called publications:

class CreatePublications < ActiveRecord::Migration[7.1]
  def change
    create_table :publications do |t|
      t.string :title
      t.text :description
      t.references :publication_type
      t.references :publisher, polymorphic: true
      t.boolean :single_issue

      t.timestamps
    end
  end
end

Note that the above code is database-agnostic: it will run in MySQL, PostgreSQL, SQLite, and others.

Rails keeps track of which migrations have been committed to the database and stores them in a neighboring table in that same database called schema_migrations.

To run the migration and create the table, you'd run bin/rails db:migrate, and to roll it back and delete the table, bin/rails db:rollback.

You can learn more about migrations in the Active Record Migrations guide.
9 Associations

Active Record associations allow you to define relationships between models. Associations can be used to describe one-to-one, one-to-many, and many-to-many relationships. For example, a relationship like “Author has many Books” can be defined as follows:

class Author < ApplicationRecord
  has_many :books
end

The Author class now has methods to add and remove books to an author, and much more.

You can learn more about associations in the Active Record Associations guide.
Feedback

You're encouraged to help improve the quality of this guide.

Please contribute if you see any typos or factual errors. To get started, you can read our documentation contributions section.

You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for main. Make sure to check Edge Guides first to verify if the issues are already fixed or not on the main branch. Check the Ruby on Rails Guides Guidelines for style and conventions.

If for whatever reason you spot something to fix but cannot patch it yourself, please open an issue.

And last but not least, any kind of discussion regarding Ruby on Rails documentation is very welcome on the official Ruby on Rails Forum.

This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License

"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.

```

# docs/rails-action-mailer.md

```md
Action Mailer Basics

This guide provides you with all you need to get started in sending emails from your application, and many internals of Action Mailer. It also covers how to test your mailers.

After reading this guide, you will know:

    How to send email within a Rails application.
    How to generate and edit an Action Mailer class and mailer view.
    How to configure Action Mailer for your environment.
    How to test your Action Mailer classes.

Chapters

    What is Action Mailer?
        Mailers are Similar to Controllers
    Sending Emails
        Walkthrough to Generating a Mailer
        Auto Encoding Header Values
        Complete List of Action Mailer Methods
        Mailer Views
        Action Mailer Layouts
        Previewing Emails
        Generating URLs in Action Mailer Views
        Adding Images in Action Mailer Views
        Sending Multipart Emails
        Sending Emails with Dynamic Delivery Options
        Sending Emails without Template Rendering
    Action Mailer Callbacks
    Using Action Mailer Helpers
    Action Mailer Configuration
        Example Action Mailer Configuration
        Action Mailer Configuration for Gmail
    Mailer Testing
    Intercepting and Observing Emails
        Intercepting Emails
        Observing Emails

1 What is Action Mailer?

Action Mailer allows you to send emails from your application using mailer classes and views.
1.1 Mailers are Similar to Controllers

They inherit from ActionMailer::Base and live in app/mailers. Mailers also work very similarly to controllers. Some examples of similarities are enumerated below. Mailers have:

    Actions, and also, associated views that appear in app/views.
    Instance variables that are accessible in views.
    The ability to utilise layouts and partials.
    The ability to access a params hash.

2 Sending Emails

This section will provide a step-by-step guide to creating a mailer and its views.
2.1 Walkthrough to Generating a Mailer
2.1.1 Create the Mailer

$ bin/rails generate mailer User
create  app/mailers/user_mailer.rb
create  app/mailers/application_mailer.rb
invoke  erb
create    app/views/user_mailer
create    app/views/layouts/mailer.text.erb
create    app/views/layouts/mailer.html.erb
invoke  test_unit
create    test/mailers/user_mailer_test.rb
create    test/mailers/previews/user_mailer_preview.rb

# app/mailers/application_mailer.rb
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout 'mailer'
end

# app/mailers/user_mailer.rb
class UserMailer < ApplicationMailer
end

As you can see, you can generate mailers just like you use other generators with Rails.

If you didn't want to use a generator, you could create your own file inside of app/mailers, just make sure that it inherits from ActionMailer::Base:

class MyMailer < ActionMailer::Base
end

2.1.2 Edit the Mailer

Mailers have methods called "actions" and they use views to structure their content. Where a controller generates content like HTML to send back to the client, a Mailer creates a message to be delivered via email.

app/mailers/user_mailer.rb contains an empty mailer:

class UserMailer < ApplicationMailer
end

Let's add a method called welcome_email, that will send an email to the user's registered email address:

class UserMailer < ApplicationMailer
  default from: 'notifications@example.com'

  def welcome_email
    @user = params[:user]
    @url  = 'http://example.com/login'
    mail(to: @user.email, subject: 'Welcome to My Awesome Site')
  end
end

Here is a quick explanation of the items presented in the preceding method. For a full list of all available options, please have a look further down at the Complete List of Action Mailer user-settable attributes section.

    The default method sets default values for all emails sent from this mailer. In this case, we use it to set the :from header value for all messages in this class. This can be overridden on a per-email basis.
    The mail method creates the actual email message. We use it to specify the values of headers like :to and :subject per email.

2.1.3 Create a Mailer View

Create a file called welcome_email.html.erb in app/views/user_mailer/. This will be the template used for the email, formatted in HTML:

<!DOCTYPE html>
<html>
  <head>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type' />
  </head>
  <body>
    <h1>Welcome to example.com, <%= @user.name %></h1>
    <p>
      You have successfully signed up to example.com,
      your username is: <%= @user.login %>.<br>
    </p>
    <p>
      To login to the site, just follow this link: <%= @url %>.
    </p>
    <p>Thanks for joining and have a great day!</p>
  </body>
</html>

Let's also make a text part for this email. Not all clients prefer HTML emails, and so sending both is best practice. To do this, create a file called welcome_email.text.erb in app/views/user_mailer/:

Welcome to example.com, <%= @user.name %>
===============================================

You have successfully signed up to example.com,
your username is: <%= @user.login %>.

To login to the site, just follow this link: <%= @url %>.

Thanks for joining and have a great day!

When you call the mail method now, Action Mailer will detect the two templates (text and HTML) and automatically generate a multipart/alternative email.
2.1.4 Calling the Mailer

Mailers are really just another way to render a view. Instead of rendering a view and sending it over the HTTP protocol, they are sending it out through the email protocols instead. Due to this, it makes sense to have your controller tell the Mailer to send an email when a user is successfully created.

Setting this up is simple.

First, let's create a User scaffold:

$ bin/rails generate scaffold user name email login
$ bin/rails db:migrate

Now that we have a user model to play with, we will edit the app/controllers/users_controller.rb file, make it instruct the UserMailer to deliver an email to the newly created user by editing the create action and inserting a call to UserMailer.with(user: @user).welcome_email right after the user is successfully saved.

We will enqueue the email to be sent by using deliver_later, which is backed by Active Job. That way, the controller action can continue without waiting for the send to complete.

class UsersController < ApplicationController
  # ...

  # POST /users or /users.json
  def create
    @user = User.new(user_params)

    respond_to do |format|
      if @user.save
        # Tell the UserMailer to send a welcome email after save
        UserMailer.with(user: @user).welcome_email.deliver_later

        format.html { redirect_to(@user, notice: 'User was successfully created.') }
        format.json { render json: @user, status: :created, location: @user }
      else
        format.html { render action: 'new' }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end

  # ...
end

Active Job's default behavior is to execute jobs via the :async adapter. So, you can use deliver_later to send emails asynchronously. Active Job's default adapter runs jobs with an in-process thread pool. It's well-suited for the development/test environments, since it doesn't require any external infrastructure, but it's a poor fit for production since it drops pending jobs on restart. If you need a persistent backend, you will need to use an Active Job adapter that has a persistent backend (Sidekiq, Resque, etc).

If you want to send emails right away (from a cronjob for example) just call deliver_now:

class SendWeeklySummary
  def run
    User.find_each do |user|
      UserMailer.with(user: user).weekly_summary.deliver_now
    end
  end
end

Any key-value pair passed to with just becomes the params for the mailer action. So with(user: @user, account: @user.account) makes params[:user] and params[:account] available in the mailer action. Just like controllers have params.

The method weekly_summary returns an ActionMailer::MessageDelivery object which can then be told to deliver_now or deliver_later to send itself out. The ActionMailer::MessageDelivery object is a wrapper around a Mail::Message. If you want to inspect, alter, or do anything else with the Mail::Message object you can access it with the message method on the ActionMailer::MessageDelivery object.
2.2 Auto Encoding Header Values

Action Mailer handles the auto encoding of multibyte characters inside of headers and bodies.

For more complex examples such as defining alternate character sets or self-encoding text first, please refer to the Mail library.
2.3 Complete List of Action Mailer Methods

There are just three methods that you need to send pretty much any email message:

    headers - Specifies any header on the email you want. You can pass a hash of header field names and value pairs, or you can call headers[:field_name] =
    'value'.
    attachments - Allows you to add attachments to your email. For example, attachments['file-name.jpg'] = File.read('file-name.jpg').
    mail - Creates the actual email itself. You can pass in headers as a hash to the mail method as a parameter. mail will create an email — either plain text or multipart — depending on what email templates you have defined.

2.3.1 Adding Attachments

Action Mailer makes it very easy to add attachments.

    Pass the file name and content and Action Mailer and the Mail gem will automatically guess the mime_type, set the encoding, and create the attachment.

    attachments['filename.jpg'] = File.read('/path/to/filename.jpg')

When the mail method will be triggered, it will send a multipart email with an attachment, properly nested with the top level being multipart/mixed and the first part being a multipart/alternative containing the plain text and HTML email messages.

Mail will automatically Base64 encode an attachment. If you want something different, encode your content and pass in the encoded content and encoding in a Hash to the attachments method.

    Pass the file name and specify headers and content and Action Mailer and Mail will use the settings you pass in.

    encoded_content = SpecialEncode(File.read('/path/to/filename.jpg'))
    attachments['filename.jpg'] = {
      mime_type: 'application/gzip',
      encoding: 'SpecialEncoding',
      content: encoded_content
    }

If you specify an encoding, Mail will assume that your content is already encoded and not try to Base64 encode it.
2.3.2 Making Inline Attachments

Action Mailer 3.0 makes inline attachments, which involved a lot of hacking in pre 3.0 versions, much simpler and trivial as they should be.

    First, to tell Mail to turn an attachment into an inline attachment, you just call #inline on the attachments method within your Mailer:

    def welcome
      attachments.inline['image.jpg'] = File.read('/path/to/image.jpg')
    end

Then in your view, you can just reference attachments as a hash and specify which attachment you want to show, calling url on it and then passing the result into the image_tag method:

<p>Hello there, this is our image</p>

<%= image_tag attachments['image.jpg'].url %>

As this is a standard call to image_tag you can pass in an options hash after the attachment URL as you could for any other image:

<p>Hello there, this is our image</p>

<%= image_tag attachments['image.jpg'].url, alt: 'My Photo', class: 'photos' %>

2.3.3 Sending Email to Multiple Recipients

It is possible to send email to one or more recipients in one email (e.g., informing all admins of a new signup) by setting the list of emails to the :to key. The list of emails can be an array of email addresses or a single string with the addresses separated by commas.

class AdminMailer < ApplicationMailer
  default to: -> { Admin.pluck(:email) },
          from: 'notification@example.com'

  def new_registration(user)
    @user = user
    mail(subject: "New User Signup: #{@user.email}")
  end
end

The same format can be used to set carbon copy (Cc:) and blind carbon copy (Bcc:) recipients, by using the :cc and :bcc keys respectively.
2.3.4 Sending Email with Name

Sometimes you wish to show the name of the person instead of just their email address when they receive the email. You can use email_address_with_name for that:

def welcome_email
  @user = params[:user]
  mail(
    to: email_address_with_name(@user.email, @user.name),
    subject: 'Welcome to My Awesome Site'
  )
end

The same technique works to specify a sender name:

class UserMailer < ApplicationMailer
  default from: email_address_with_name('notification@example.com', 'Example Company Notifications')
end

If the name is a blank string, it returns just the address.
2.4 Mailer Views

Mailer views are located in the app/views/name_of_mailer_class directory. The specific mailer view is known to the class because its name is the same as the mailer method. In our example from above, our mailer view for the welcome_email method will be in app/views/user_mailer/welcome_email.html.erb for the HTML version and welcome_email.text.erb for the plain text version.

To change the default mailer view for your action you do something like:

class UserMailer < ApplicationMailer
  default from: 'notifications@example.com'

  def welcome_email
    @user = params[:user]
    @url  = 'http://example.com/login'
    mail(to: @user.email,
         subject: 'Welcome to My Awesome Site',
         template_path: 'notifications',
         template_name: 'another')
  end
end

In this case, it will look for templates at app/views/notifications with name another. You can also specify an array of paths for template_path, and they will be searched in order.

If you want more flexibility you can also pass a block and render specific templates or even render inline or text without using a template file:

class UserMailer < ApplicationMailer
  default from: 'notifications@example.com'

  def welcome_email
    @user = params[:user]
    @url  = 'http://example.com/login'
    mail(to: @user.email,
         subject: 'Welcome to My Awesome Site') do |format|
      format.html { render 'another_template' }
      format.text { render plain: 'Render text' }
    end
  end
end

This will render the template 'another_template.html.erb' for the HTML part and use the rendered text for the text part. The render command is the same one used inside of Action Controller, so you can use all the same options, such as :text, :inline, etc.

If you would like to render a template located outside of the default app/views/mailer_name/ directory, you can apply the prepend_view_path, like so:

class UserMailer < ApplicationMailer
  prepend_view_path "custom/path/to/mailer/view"

  # This will try to load "custom/path/to/mailer/view/welcome_email" template
  def welcome_email
    # ...
  end
end

You can also consider using the append_view_path method.
2.4.1 Caching Mailer View

You can perform fragment caching in mailer views like in application views using the cache method.

<% cache do %>
  <%= @company.name %>
<% end %>

And to use this feature, you need to configure your application with this:

config.action_mailer.perform_caching = true

Fragment caching is also supported in multipart emails. Read more about caching in the Rails caching guide.
2.5 Action Mailer Layouts

Just like controller views, you can also have mailer layouts. The layout name needs to be the same as your mailer, such as user_mailer.html.erb and user_mailer.text.erb to be automatically recognized by your mailer as a layout.

To use a different file, call layout in your mailer:

class UserMailer < ApplicationMailer
  layout 'awesome' # use awesome.(html|text).erb as the layout
end

Just like with controller views, use yield to render the view inside the layout.

You can also pass in a layout: 'layout_name' option to the render call inside the format block to specify different layouts for different formats:

class UserMailer < ApplicationMailer
  def welcome_email
    mail(to: params[:user].email) do |format|
      format.html { render layout: 'my_layout' }
      format.text
    end
  end
end

Will render the HTML part using the my_layout.html.erb file and the text part with the usual user_mailer.text.erb file if it exists.
2.6 Previewing Emails

Action Mailer previews provide a way to see how emails look by visiting a special URL that renders them. In the above example, the preview class for UserMailer should be named UserMailerPreview and located in test/mailers/previews/user_mailer_preview.rb. To see the preview of welcome_email, implement a method that has the same name and call UserMailer.welcome_email:

class UserMailerPreview < ActionMailer::Preview
  def welcome_email
    UserMailer.with(user: User.first).welcome_email
  end
end

Then the preview will be available in http://localhost:3000/rails/mailers/user_mailer/welcome_email.

If you change something in app/views/user_mailer/welcome_email.html.erb or the mailer itself, it'll automatically reload and render it so you can visually see the new style instantly. A list of previews are also available in http://localhost:3000/rails/mailers.

By default, these preview classes live in test/mailers/previews. This can be configured using the preview_paths option. For example, if you want to add lib/mailer_previews to it, you can configure it in config/application.rb:

config.action_mailer.preview_paths << "#{Rails.root}/lib/mailer_previews"

2.7 Generating URLs in Action Mailer Views

Unlike controllers, the mailer instance doesn't have any context about the incoming request so you'll need to provide the :host parameter yourself.

As the :host usually is consistent across the application you can configure it globally in config/application.rb:

config.action_mailer.default_url_options = { host: 'example.com' }

Because of this behavior, you cannot use any of the *_path helpers inside of an email. Instead, you will need to use the associated *_url helper. For example instead of using

<%= link_to 'welcome', welcome_path %>

You will need to use:

<%= link_to 'welcome', welcome_url %>

By using the full URL, your links will now work in your emails.
2.7.1 Generating URLs with url_for

url_for generates a full URL by default in templates.

If you did not configure the :host option globally make sure to pass it to url_for.

<%= url_for(host: 'example.com',
            controller: 'welcome',
            action: 'greeting') %>

2.7.2 Generating URLs with Named Routes

Email clients have no web context and so paths have no base URL to form complete web addresses. Thus, you should always use the *_url variant of named route helpers.

If you did not configure the :host option globally make sure to pass it to the URL helper.

<%= user_url(@user, host: 'example.com') %>

non-GET links require rails-ujs or jQuery UJS, and won't work in mailer templates. They will result in normal GET requests.
2.8 Adding Images in Action Mailer Views

Unlike controllers, the mailer instance doesn't have any context about the incoming request so you'll need to provide the :asset_host parameter yourself.

As the :asset_host usually is consistent across the application you can configure it globally in config/application.rb:

config.action_mailer.asset_host = 'http://example.com'

Because we can't infer the protocol from the request, you'll need to specify a protocol such as http:// or https:// in the :asset_host config.

Now you can display an image inside your email.

<%= image_tag 'image.jpg' %>

2.9 Sending Multipart Emails

Action Mailer will automatically send multipart emails if you have different templates for the same action. So, for our UserMailer example, if you have welcome_email.text.erb and welcome_email.html.erb in app/views/user_mailer, Action Mailer will automatically send a multipart email with the HTML and text versions setup as different parts.

The order of the parts getting inserted is determined by the :parts_order inside of the ActionMailer::Base.default method.
2.10 Sending Emails with Dynamic Delivery Options

If you wish to override the default delivery options (e.g. SMTP credentials) while delivering emails, you can do this using delivery_method_options in the mailer action.

class UserMailer < ApplicationMailer
  def welcome_email
    @user = params[:user]
    @url  = user_url(@user)
    delivery_options = { user_name: params[:company].smtp_user,
                         password: params[:company].smtp_password,
                         address: params[:company].smtp_host }
    mail(to: @user.email,
         subject: "Please see the Terms and Conditions attached",
         delivery_method_options: delivery_options)
  end
end

2.11 Sending Emails without Template Rendering

There may be cases in which you want to skip the template rendering step and supply the email body as a string. You can achieve this using the :body option. In such cases don't forget to add the :content_type option. Rails will default to text/plain otherwise.

class UserMailer < ApplicationMailer
  def welcome_email
    mail(to: params[:user].email,
         body: params[:email_body],
         content_type: "text/html",
         subject: "Already rendered!")
  end
end

3 Action Mailer Callbacks

Action Mailer allows for you to specify a before_action, after_action and around_action to configure the message, and before_deliver, after_deliver and around_deliver to control the delivery.

    Callbacks can be specified with a block or a symbol to a method in the mailer class similar to controllers.

    You could use a before_action to set instance variables, populate the mail object with defaults, or insert default headers and attachments.

class InvitationsMailer < ApplicationMailer
  before_action :set_inviter_and_invitee
  before_action { @account = params[:inviter].account }

  default to:       -> { @invitee.email_address },
          from:     -> { common_address(@inviter) },
          reply_to: -> { @inviter.email_address_with_name }

  def account_invitation
    mail subject: "#{@inviter.name} invited you to their Basecamp (#{@account.name})"
  end

  def project_invitation
    @project    = params[:project]
    @summarizer = ProjectInvitationSummarizer.new(@project.bucket)

    mail subject: "#{@inviter.name.familiar} added you to a project in Basecamp (#{@account.name})"
  end

  private
    def set_inviter_and_invitee
      @inviter = params[:inviter]
      @invitee = params[:invitee]
    end
end

    You could use an after_action to do similar setup as a before_action but using instance variables set in your mailer action.

    Using an after_action callback also enables you to override delivery method settings by updating mail.delivery_method.settings.

class UserMailer < ApplicationMailer
  before_action { @business, @user = params[:business], params[:user] }

  after_action :set_delivery_options,
               :prevent_delivery_to_guests,
               :set_business_headers

  def feedback_message
  end

  def campaign_message
  end

  private
    def set_delivery_options
      # You have access to the mail instance,
      # @business and @user instance variables here
      if @business && @business.has_smtp_settings?
        mail.delivery_method.settings.merge!(@business.smtp_settings)
      end
    end

    def prevent_delivery_to_guests
      if @user && @user.guest?
        mail.perform_deliveries = false
      end
    end

    def set_business_headers
      if @business
        headers["X-SMTPAPI-CATEGORY"] = @business.code
      end
    end
end

    You could use an after_deliver to record the delivery of the message. It also allows observer/interceptor-like behaviors, but with access to the full mailer context.

class UserMailer < ApplicationMailer
  after_deliver :mark_delivered
  before_deliver :sandbox_staging
  after_deliver :observe_delivery

  def feedback_message
    @feedback = params[:feedback]
  end

  private
    def mark_delivered
      params[:feedback].touch(:delivered_at)
    end

    # An Interceptor alternative.
    def sandbox_staging
      message.to = ['sandbox@example.com'] if Rails.env.staging?
    end

    # A callback has more context than the comparable Observer example.
    def observe_delivery
      EmailDelivery.log(message, self.class, action_name, params)
    end
end

    Mailer callbacks abort further processing if body is set to a non-nil value. before_deliver can abort with throw :abort.

4 Using Action Mailer Helpers

Action Mailer inherits from AbstractController, so you have access to most of the same helpers as you do in Action Controller.

There are also some Action Mailer-specific helper methods available in ActionMailer::MailHelper. For example, these allow accessing the mailer instance from your view with mailer, and accessing the message as message:

<%= stylesheet_link_tag mailer.name.underscore %>
<h1><%= message.subject %></h1>

5 Action Mailer Configuration

The following configuration options are best made in one of the environment files (environment.rb, production.rb, etc...)
Configuration 	Description
logger 	Generates information on the mailing run if available. Can be set to nil for no logging. Compatible with both Ruby's own Logger and Log4r loggers.
smtp_settings 	Allows detailed configuration for :smtp delivery method:

    :address - Allows you to use a remote mail server. Just change it from its default "localhost" setting.
    :port - On the off chance that your mail server doesn't run on port 25, you can change it.
    :domain - If you need to specify a HELO domain, you can do it here.
    :user_name - If your mail server requires authentication, set the username in this setting.
    :password - If your mail server requires authentication, set the password in this setting.
    :authentication - If your mail server requires authentication, you need to specify the authentication type here. This is a symbol and one of :plain (will send the password in the clear), :login (will send password Base64 encoded) or :cram_md5 (combines a Challenge/Response mechanism to exchange information and a cryptographic Message Digest 5 algorithm to hash important information)
    :enable_starttls - Use STARTTLS when connecting to your SMTP server and fail if unsupported. Defaults to false.
    :enable_starttls_auto - Detects if STARTTLS is enabled in your SMTP server and starts to use it. Defaults to true.
    :openssl_verify_mode - When using TLS, you can set how OpenSSL checks the certificate. This is really useful if you need to validate a self-signed and/or a wildcard certificate. You can use the name of an OpenSSL verify constant ('none' or 'peer') or directly the constant (OpenSSL::SSL::VERIFY_NONE or OpenSSL::SSL::VERIFY_PEER).
    :ssl/:tls - Enables the SMTP connection to use SMTP/TLS (SMTPS: SMTP over direct TLS connection)
    :open_timeout - Number of seconds to wait while attempting to open a connection.
    :read_timeout - Number of seconds to wait until timing-out a read(2) call.

sendmail_settings 	Allows you to override options for the :sendmail delivery method.

    :location - The location of the sendmail executable. Defaults to /usr/sbin/sendmail.
    :arguments - The command line arguments to be passed to sendmail. Defaults to ["-i"].

raise_delivery_errors 	Whether or not errors should be raised if the email fails to be delivered. This only works if the external email server is configured for immediate delivery. Defaults to true.
delivery_method 	Defines a delivery method. Possible values are:

    :smtp (default), can be configured by using config.action_mailer.smtp_settings.
    :sendmail, can be configured by using config.action_mailer.sendmail_settings.
    :file: save emails to files; can be configured by using config.action_mailer.file_settings.
    :test: save emails to ActionMailer::Base.deliveries array.

See API docs for more info.
perform_deliveries 	Determines whether deliveries are actually carried out when the deliver method is invoked on the Mail message. By default they are, but this can be turned off to help functional testing. If this value is false, deliveries array will not be populated even if delivery_method is :test.
deliveries 	Keeps an array of all the emails sent out through the Action Mailer with delivery_method :test. Most useful for unit and functional testing.
delivery_job 	The job class used with deliver_later. Defaults to ActionMailer::MailDeliveryJob.
deliver_later_queue_name 	The name of the queue used with the default delivery_job. Defaults to the default Active Job queue.
default_options 	Allows you to set default values for the mail method options (:from, :reply_to, etc.).

For a complete writeup of possible configurations see the Configuring Action Mailer in our Configuring Rails Applications guide.
5.1 Example Action Mailer Configuration

An example would be adding the following to your appropriate config/environments/$RAILS_ENV.rb file:

config.action_mailer.delivery_method = :sendmail
# Defaults to:
# config.action_mailer.sendmail_settings = {
#   location: '/usr/sbin/sendmail',
#   arguments: %w[ -i ]
# }
config.action_mailer.perform_deliveries = true
config.action_mailer.raise_delivery_errors = true
config.action_mailer.default_options = { from: 'no-reply@example.com' }

5.2 Action Mailer Configuration for Gmail

Action Mailer uses the Mail gem and accepts similar configuration. Add this to your config/environments/$RAILS_ENV.rb file to send via Gmail:

config.action_mailer.delivery_method = :smtp
config.action_mailer.smtp_settings = {
  address:         'smtp.gmail.com',
  port:            587,
  domain:          'example.com',
  user_name:       '<username>',
  password:        '<password>',
  authentication:  'plain',
  enable_starttls: true,
  open_timeout:    5,
  read_timeout:    5 }

If you are using an old version of the Mail gem (2.6.x or earlier), use enable_starttls_auto instead of enable_starttls.

Google blocks sign-ins from apps it deems less secure. You can change your Gmail settings here to allow the attempts. If your Gmail account has 2-factor authentication enabled, then you will need to set an app password and use that instead of your regular password.
6 Mailer Testing

You can find detailed instructions on how to test your mailers in the testing guide.
7 Intercepting and Observing Emails

Action Mailer provides hooks into the Mail observer and interceptor methods. These allow you to register classes that are called during the mail delivery life cycle of every email sent.
7.1 Intercepting Emails

Interceptors allow you to make modifications to emails before they are handed off to the delivery agents. An interceptor class must implement the ::delivering_email(message) method which will be called before the email is sent.

class SandboxEmailInterceptor
  def self.delivering_email(message)
    message.to = ['sandbox@example.com']
  end
end

Before the interceptor can do its job you need to register it using the interceptors config option. You can do this in an initializer file like config/initializers/mail_interceptors.rb:

Rails.application.configure do
  if Rails.env.staging?
    config.action_mailer.interceptors = %w[SandboxEmailInterceptor]
  end
end

The example above uses a custom environment called "staging" for a production-like server but for testing purposes. You can read Creating Rails Environments for more information about custom Rails environments.
7.2 Observing Emails

Observers give you access to the email message after it has been sent. An observer class must implement the :delivered_email(message) method, which will be called after the email is sent.

class EmailDeliveryObserver
  def self.delivered_email(message)
    EmailDelivery.log(message)
  end
end

Similar to interceptors, you must register observers using the observers config option. You can do this in an initializer file like config/initializers/mail_observers.rb:

Rails.application.configure do
  config.action_mailer.observers = %w[EmailDeliveryObserver]
end

Feedback

You're encouraged to help improve the quality of this guide.

Please contribute if you see any typos or factual errors. To get started, you can read our documentation contributions section.

You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for main. Make sure to check Edge Guides first to verify if the issues are already fixed or not on the main branch. Check the Ruby on Rails Guides Guidelines for style and conventions.

If for whatever reason you spot something to fix but cannot patch it yourself, please open an issue.

And last but not least, any kind of discussion regarding Ruby on Rails documentation is very welcome on the official Ruby on Rails Forum.

This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License

"Rails", "Ruby on Rails", and the Rails logo are trademarks of David Heinemeier Hansson. All rights reserved.

```

# docs/claude-ruby.md

```md
claude-ruby gem is an unofficial ruby SDK for interacting with the Anthropic API, for generating and streaming messages through Claude
Installation

Add this line to your application's Gemfile:

gem 'claude-ruby'

And then execute:

$ bundle install

Or install it yourself as:

$ gem install claude-ruby

Usage

To use this gem you'll need an API key from Anthropic, which can be obtained from the Anthropic console
by following the Get API Access link on the Anthropic API page.

Set your API key as an environment variable then you can create a new Claude::Client instance:

require 'claude/client'

api_key = ENV['YOUR_ANTHROPIC_API_KEY']
claude_client = Claude::Client.new(api_key)

Messages

The anthropic messages endpoint allows you to:

Send a structured list of input messages with text and/or image content, 
and the model will generate the next message in the conversation.
The Messages API can be used for for either single queries or stateless multi-turn conversations.

Using the claude-ruby gem you can call the Anthropic messages API by passing in an array of messages where each element is a hash containing role and content properties.

The messages method allows converse with the Claude model in chat form. It requires an array of messages where each message is a hash with two properties: role and content.

role can be:

    'user': This represents the user's input.
    'assistant': This optional role represents the model's output.

Simple example with a single user message:

messages = claude_client.user_message("Who was the first team to win the rugby world cup?")
response = claude_client.messages(messages)

The response contains a bunch of metadata and the model's message response. To extract the message text you can use:

claude_client.parse_response(response)

Or parse the response yourself:

response['content'][0]['text']

claude_client.user_message is just for simple user messages. For more complex messages you can specify the payload in detail:

messages = [
  {
    role: "user",
    content: "In which year was the first ever rugby world cup? (A) 1983 (B) 1987 (C) 1991"
  },
  {
    role: "assistant",
    content: "The best answer is ("
  }
]

response = claude_client.messages(messages)

You can continue the conversation by calling the messages method again with an expanded messages array:

messages = [{ role: "user", content: "Who was the first team to win the rugby world cup?" }]
messages << { role: "assistant", content: "New Zealand won the first Rugby World Cup in 1987" }
messages << { role: "user", content: "Who came third and fourth in that competition?" }

response = claude_client.messages(messages)
puts claude_client.parse_response(response) # This will give you the updated message

Example with a more sophisticated message structure:

system = "Only reply in Spanish."

messages = [
  {
    role: "user",
    content: "Hi there."
  },
  {
    role: "assistant",
    content: "Hola, como estás?"
  },
  {
    role: "user",
    content: "How long does it take to fly from Auckland to Buenos Aires?"
  },
]

response = claude_client.messages(messages, { system: system })

Models

If you don't specify a model, then the gem will use the latest version of Claude Sonnet by default, which is currently claude-3-5-sonnet-20240620

You can use a different model by specifying it as a parameter in the messages call:

response = claude_client.messages(messages, { model: 'claude-3-haiku-20240307' })

There are some constants defined so you can choose an appropriate model for your use-case and not have to worry about updating it when new Claude models are released:

Claude::Model::CLAUDE_OPUS_LATEST
Claude::Model::CLAUDE_SONNET_LATEST
Claude::Model::CLAUDE_HAIKU_LATEST

Claude::Model::CLAUDE_FASTEST
Claude::Model::CLAUDE_CHEAPEST
Claude::Model::CLAUDE_BALANCED
Claude::Model::CLAUDE_SMARTEST

Example usage:

response = claude_client.messages(messages, { model: Claude::Model::CLAUDE_CHEAPEST })

Timeout

You can optionally set a timeout (integer) which will determine the maximum number of seconds to wait for the API call to complete.

There are two ways to do this:

    Set a default timeout when instantiating the claude_client
    This timeout value will be used for all API calls unless overridden.

claude_client = Claude::Client.new(api_key, timeout: 10)

    Pass in a timeout value as a parameter when calling the messages method.
    This timeout value will be used only for that specific messages request.

response = claude_client.messages(messages, { timeout: 10 })

Parameters

You can pass in any of the following parameters, which will be included in the Anthropic API call:

model
system
max_tokens
metadata
stop_sequences
stream
temperature
top_p
top_k

timeout (*)

(*) timeout is used for the HTTP request but not passed with the API data

Example:

response = claude_client.messages(messages, 
                                  { model: Claude::Model::CLAUDE_SMARTEST,
                                    max_tokens: 500,
                                    temperature: 0.1 })


```

# test/system/.keep

```

```

# test/models/.keep

```

```

# test/integration/.keep

```

```

# test/controllers/.keep

```

```

# lib/assets/.keep

```

```

# lib/tasks/.keep

```

```

# test/mailers/.keep

```

```

# test/helpers/.keep

```

```

# config/locales/en.yml

```yml
# Files in the config/locales directory are used for internationalization
# and are automatically loaded by Rails. If you want to use locales other
# than English, add the necessary files in this directory.
#
# To use the locales, use `I18n.t`:
#
#     I18n.t "hello"
#
# In views, this is aliased to just `t`:
#
#     <%= t("hello") %>
#
# To use a different locale, set it with `I18n.locale`:
#
#     I18n.locale = :es
#
# This would use the information in config/locales/es.yml.
#
# The following keys must be escaped otherwise they will not be retrieved by
# the default I18n backend:
#
# true, false, on, off, yes, no
#
# Instead, surround them with single quotes.
#
# en:
#   "true": "foo"
#
# To learn more, please read the Rails Internationalization guide
# available at https://guides.rubyonrails.org/i18n.html.

en:
  hello: "Hello world"

```

# config/initializers/permissions_policy.rb

```rb
# Define an application-wide HTTP permissions policy. For further
# information see https://developers.google.com/web/updates/2018/06/feature-policy
#
# Rails.application.config.permissions_policy do |f|
#   f.camera      :none
#   f.gyroscope   :none
#   f.microphone  :none
#   f.usb         :none
#   f.fullscreen  :self
#   f.payment     :self, "https://secure.example.com"
# end

```

# config/initializers/inflections.rb

```rb
# Be sure to restart your server when you modify this file.

# Add new inflection rules using the following format. Inflections
# are locale specific, and you may define rules for as many different
# locales as you wish. All of these examples are active by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.plural /^(ox)$/i, "\\1en"
#   inflect.singular /^(ox)en/i, "\\1"
#   inflect.irregular "person", "people"
#   inflect.uncountable %w( fish sheep )
# end

# These inflection rules are supported but not enabled by default:
# ActiveSupport::Inflector.inflections(:en) do |inflect|
#   inflect.acronym "RESTful"
# end

```

# config/initializers/filter_parameter_logging.rb

```rb
# Be sure to restart your server when you modify this file.

# Configure parameters to be filtered from the log file. Use this to limit dissemination of
# sensitive information. See the ActiveSupport::ParameterFilter documentation for supported
# notations and behaviors.
Rails.application.config.filter_parameters += [
  :passw, :secret, :token, :_key, :crypt, :salt, :certificate, :otp, :ssn
]

```

# config/initializers/content_security_policy.rb

```rb
# Be sure to restart your server when you modify this file.

# Define an application-wide content security policy.
# See the Securing Rails Applications Guide for more information:
# https://guides.rubyonrails.org/security.html#content-security-policy-header

# Rails.application.configure do
#   config.content_security_policy do |policy|
#     policy.default_src :self, :https
#     policy.font_src    :self, :https, :data
#     policy.img_src     :self, :https, :data
#     policy.object_src  :none
#     policy.script_src  :self, :https
#     policy.style_src   :self, :https
#     # Specify URI for violation reports
#     # policy.report_uri "/csp-violation-report-endpoint"
#   end
#
#   # Generate session nonces for permitted importmap and inline scripts
#   config.content_security_policy_nonce_generator = ->(request) { request.session.id.to_s }
#   config.content_security_policy_nonce_directives = %w(script-src)
#
#   # Report violations without enforcing the policy.
#   # config.content_security_policy_report_only = true
# end

```

# config/initializers/assets.rb

```rb
# Be sure to restart your server when you modify this file.

# Version of your assets, change this if you want to expire all your assets.
Rails.application.config.assets.version = "1.0"

# Add additional assets to the asset load path.
# Rails.application.config.assets.paths << Emoji.images_path

# Precompile additional assets.
# application.js, application.css, and all non-JS/CSS in the app/assets
# folder are already added.
# Rails.application.config.assets.precompile += %w( admin.js admin.css )

```

# config/environments/test.rb

```rb
require "active_support/core_ext/integer/time"

# The test environment is used exclusively to run your application's
# test suite. You never need to work with it otherwise. Remember that
# your test database is "scratch space" for the test suite and is wiped
# and recreated between test runs. Don't rely on the data there!

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # Turn false under Spring and add config.action_view.cache_template_loading = true.
  config.cache_classes = true

  # Eager loading loads your whole application. When running a single test locally,
  # this probably isn't necessary. It's a good idea to do in a continuous integration
  # system, or in some way before deploying your code.
  config.eager_load = ENV["CI"].present?

  # Configure public file server for tests with Cache-Control for performance.
  config.public_file_server.enabled = true
  config.public_file_server.headers = {
    "Cache-Control" => "public, max-age=#{1.hour.to_i}"
  }

  # Show full error reports and disable caching.
  config.consider_all_requests_local       = true
  config.action_controller.perform_caching = false
  config.cache_store = :null_store

  # Raise exceptions instead of rendering exception templates.
  config.action_dispatch.show_exceptions = false

  # Disable request forgery protection in test environment.
  config.action_controller.allow_forgery_protection = false

  # Store uploaded files on the local file system in a temporary directory.
  config.active_storage.service = :test

  config.action_mailer.perform_caching = false

  # Tell Action Mailer not to deliver emails to the real world.
  # The :test delivery method accumulates sent emails in the
  # ActionMailer::Base.deliveries array.
  config.action_mailer.delivery_method = :test

  # Print deprecation notices to the stderr.
  config.active_support.deprecation = :stderr

  # Raise exceptions for disallowed deprecations.
  config.active_support.disallowed_deprecation = :raise

  # Tell Active Support which deprecation messages to disallow.
  config.active_support.disallowed_deprecation_warnings = []

  # Raises error for missing translations.
  # config.i18n.raise_on_missing_translations = true

  # Annotate rendered view with file names.
  # config.action_view.annotate_rendered_view_with_filenames = true
end

```

# config/environments/production.rb

```rb
require "active_support/core_ext/integer/time"

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # Code is not reloaded between requests.
  config.cache_classes = true

  # Eager load code on boot. This eager loads most of Rails and
  # your application in memory, allowing both threaded web servers
  # and those relying on copy on write to perform better.
  # Rake tasks automatically ignore this option for performance.
  config.eager_load = true

  # Full error reports are disabled and caching is turned on.
  config.consider_all_requests_local       = false
  config.action_controller.perform_caching = true

  # Ensures that a master key has been made available in either ENV["RAILS_MASTER_KEY"]
  # or in config/master.key. This key is used to decrypt credentials (and other encrypted files).
  # config.require_master_key = true

  # Disable serving static files from the `/public` folder by default since
  # Apache or NGINX already handles this.
  config.public_file_server.enabled = ENV["RAILS_SERVE_STATIC_FILES"].present?

  # Compress CSS using a preprocessor.
  # config.assets.css_compressor = :sass

  # Do not fallback to assets pipeline if a precompiled asset is missed.
  config.assets.compile = false

  # Enable serving of images, stylesheets, and JavaScripts from an asset server.
  # config.asset_host = "http://assets.example.com"

  # Specifies the header that your server uses for sending files.
  # config.action_dispatch.x_sendfile_header = "X-Sendfile" # for Apache
  # config.action_dispatch.x_sendfile_header = "X-Accel-Redirect" # for NGINX

  # Store uploaded files on the local file system (see config/storage.yml for options).
  config.active_storage.service = :local

  # Mount Action Cable outside main process or domain.
  # config.action_cable.mount_path = nil
  # config.action_cable.url = "wss://example.com/cable"
  # config.action_cable.allowed_request_origins = [ "http://example.com", /http:\/\/example.*/ ]

  # Force all access to the app over SSL, use Strict-Transport-Security, and use secure cookies.
  # config.force_ssl = true

  # Include generic and useful information about system operation, but avoid logging too much
  # information to avoid inadvertent exposure of personally identifiable information (PII).
  config.log_level = :info

  # Prepend all log lines with the following tags.
  config.log_tags = [ :request_id ]

  # Use a different cache store in production.
  # config.cache_store = :mem_cache_store

  # Use a real queuing backend for Active Job (and separate queues per environment).
  # config.active_job.queue_adapter     = :resque
  # config.active_job.queue_name_prefix = "interview_production"

  config.action_mailer.perform_caching = false

  # Ignore bad email addresses and do not raise email delivery errors.
  # Set this to true and configure the email server for immediate delivery to raise delivery errors.
  # config.action_mailer.raise_delivery_errors = false

  # Enable locale fallbacks for I18n (makes lookups for any locale fall back to
  # the I18n.default_locale when a translation cannot be found).
  config.i18n.fallbacks = true

  # Don't log any deprecations.
  config.active_support.report_deprecations = false

  # Use default logging formatter so that PID and timestamp are not suppressed.
  config.log_formatter = ::Logger::Formatter.new

  # Use a different logger for distributed setups.
  # require "syslog/logger"
  # config.logger = ActiveSupport::TaggedLogging.new(Syslog::Logger.new "app-name")

  if ENV["RAILS_LOG_TO_STDOUT"].present?
    logger           = ActiveSupport::Logger.new(STDOUT)
    logger.formatter = config.log_formatter
    config.logger    = ActiveSupport::TaggedLogging.new(logger)
  end

  # Do not dump schema after migrations.
  config.active_record.dump_schema_after_migration = false
end

```

# config/environments/development.rb

```rb
require "active_support/core_ext/integer/time"

Rails.application.configure do
  # Settings specified here will take precedence over those in config/application.rb.

  # In the development environment your application's code is reloaded any time
  # it changes. This slows down response time but is perfect for development
  # since you don't have to restart the web server when you make code changes.
  config.cache_classes = false

  # Do not eager load code on boot.
  config.eager_load = false

  # Show full error reports.
  config.consider_all_requests_local = true

  # Enable server timing
  config.server_timing = true

  # Enable/disable caching. By default caching is disabled.
  # Run rails dev:cache to toggle caching.
  if Rails.root.join("tmp/caching-dev.txt").exist?
    config.action_controller.perform_caching = true
    config.action_controller.enable_fragment_cache_logging = true

    config.cache_store = :memory_store
    config.public_file_server.headers = {
      "Cache-Control" => "public, max-age=#{2.days.to_i}"
    }
  else
    config.action_controller.perform_caching = false

    config.cache_store = :null_store
  end

  # Store uploaded files on the local file system (see config/storage.yml for options).
  config.active_storage.service = :local

  # Don't care if the mailer can't send.
  config.action_mailer.raise_delivery_errors = false

  config.action_mailer.perform_caching = false

  # Print deprecation notices to the Rails logger.
  config.active_support.deprecation = :log

  # Raise exceptions for disallowed deprecations.
  config.active_support.disallowed_deprecation = :raise

  # Tell Active Support which deprecation messages to disallow.
  config.active_support.disallowed_deprecation_warnings = []

  # Raise an error on page load if there are pending migrations.
  config.active_record.migration_error = :page_load

  # Highlight code that triggered database queries in logs.
  config.active_record.verbose_query_logs = true

  # Suppress logger output for asset requests.
  config.assets.quiet = true

  # Raises error for missing translations.
  # config.i18n.raise_on_missing_translations = true

  # Annotate rendered view with file names.
  # config.action_view.annotate_rendered_view_with_filenames = true

  # Uncomment if you wish to allow Action Cable access from any origin.
  # config.action_cable.disable_request_forgery_protection = true
end

```

# app/models/application_record.rb

```rb
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end

```

# app/mailers/application_mailer.rb

```rb
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout "mailer"
end

```

# app/javascript/application.js

```js
// Configure your import map in config/importmap.rb. Read more: https://github.com/rails/importmap-rails
import "@hotwired/turbo-rails"

```

# app/controllers/application_controller.rb

```rb
class ApplicationController < ActionController::Base
end

```

# app/jobs/application_job.rb

```rb
class ApplicationJob < ActiveJob::Base
  # Automatically retry jobs that encountered a deadlock
  # retry_on ActiveRecord::Deadlocked

  # Most jobs are safe to ignore if the underlying records are no longer available
  # discard_on ActiveJob::DeserializationError
end

```

# app/helpers/application_helper.rb

```rb
module ApplicationHelper
end

```

# test/fixtures/files/.keep

```

```

# test/channels/application_cable/connection_test.rb

```rb
require "test_helper"

class ApplicationCable::ConnectionTest < ActionCable::Connection::TestCase
  # test "connects with cookies" do
  #   cookies.signed[:user_id] = 42
  #
  #   connect
  #
  #   assert_equal connection.user_id, "42"
  # end
end

```

# app/views/layouts/mailer.text.erb

```erb
<%= yield %>

```

# app/views/layouts/mailer.html.erb

```erb
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <style>
      /* Email styles need to be inline */
    </style>
  </head>

  <body>
    <%= yield %>
  </body>
</html>

```

# app/views/layouts/application.html.erb

```erb
<!DOCTYPE html>
<html>
  <head>
    <title>Interview</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <%= csrf_meta_tags %>
    <%= csp_meta_tag %>

    <%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>
    <%= javascript_importmap_tags %>
  </head>

  <body>
    <%= yield %>
  </body>
</html>

```

# app/models/concerns/.keep

```

```

# app/controllers/concerns/.keep

```

```

# app/channels/application_cable/connection.rb

```rb
module ApplicationCable
  class Connection < ActionCable::Connection::Base
  end
end

```

# app/channels/application_cable/channel.rb

```rb
module ApplicationCable
  class Channel < ActionCable::Channel::Base
  end
end

```

# app/assets/stylesheets/application.css

```css
/*
 * This is a manifest file that'll be compiled into application.css, which will include all the files
 * listed below.
 *
 * Any CSS (and SCSS, if configured) file within this directory, lib/assets/stylesheets, or any plugin's
 * vendor/assets/stylesheets directory can be referenced here using a relative path.
 *
 * You're free to add application-wide styles to this file and they'll appear at the bottom of the
 * compiled file so the styles you add here take precedence over styles defined in any other CSS
 * files in this directory. Styles in this file should be added after the last require_* statement.
 * It is generally better to create a new file per style scope.
 *
 *= require_tree .
 *= require_self
 */

```

# app/assets/images/.keep

```

```

# app/assets/config/manifest.js

```js
//= link_tree ../images
//= link_directory ../stylesheets .css
//= link_tree ../../javascript .js
//= link_tree ../../../vendor/javascript .js

```

